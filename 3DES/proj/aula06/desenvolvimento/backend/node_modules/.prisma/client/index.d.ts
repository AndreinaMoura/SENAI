
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model usuario
 * 
 */
export type usuario = {
  id: number
  nome: string
  email: string
  senha: string
  nivel: number
}

/**
 * Model motorista
 * 
 */
export type motorista = {
  id: number
  nome: string
  ocupado: boolean
}

/**
 * Model tipo_veiculos
 * 
 */
export type tipo_veiculos = {
  id: number
  tipo: string
}

/**
 * Model veiculos
 * 
 */
export type veiculos = {
  id: number
  placa: string
  tipo: number
  uso: boolean
}

/**
 * Model operacoes
 * 
 */
export type operacoes = {
  id: number
  veiculo: number
  motorista: number
  data_saida: Date
  descricao: string
  data_retorno: Date | null
  concluidas: boolean
}

/**
 * Model manutencao
 * 
 */
export type manutencao = {
  id: number
  veiculo: number
  data_inicio: Date
  valor: number
  descricao: string
  data_fim: Date | null
  concluidas: boolean
}

/**
 * Model relatorio_manutencao
 * 
 */
export type relatorio_manutencao = {
  id: number
  manutencao: number
}

/**
 * Model relatorio_operacao
 * 
 */
export type relatorio_operacao = {
  id: number
  operacoes: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.usuarioDelegate<GlobalReject>;

  /**
   * `prisma.motorista`: Exposes CRUD operations for the **motorista** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Motoristas
    * const motoristas = await prisma.motorista.findMany()
    * ```
    */
  get motorista(): Prisma.motoristaDelegate<GlobalReject>;

  /**
   * `prisma.tipo_veiculos`: Exposes CRUD operations for the **tipo_veiculos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipo_veiculos
    * const tipo_veiculos = await prisma.tipo_veiculos.findMany()
    * ```
    */
  get tipo_veiculos(): Prisma.tipo_veiculosDelegate<GlobalReject>;

  /**
   * `prisma.veiculos`: Exposes CRUD operations for the **veiculos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Veiculos
    * const veiculos = await prisma.veiculos.findMany()
    * ```
    */
  get veiculos(): Prisma.veiculosDelegate<GlobalReject>;

  /**
   * `prisma.operacoes`: Exposes CRUD operations for the **operacoes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operacoes
    * const operacoes = await prisma.operacoes.findMany()
    * ```
    */
  get operacoes(): Prisma.operacoesDelegate<GlobalReject>;

  /**
   * `prisma.manutencao`: Exposes CRUD operations for the **manutencao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Manutencaos
    * const manutencaos = await prisma.manutencao.findMany()
    * ```
    */
  get manutencao(): Prisma.manutencaoDelegate<GlobalReject>;

  /**
   * `prisma.relatorio_manutencao`: Exposes CRUD operations for the **relatorio_manutencao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Relatorio_manutencaos
    * const relatorio_manutencaos = await prisma.relatorio_manutencao.findMany()
    * ```
    */
  get relatorio_manutencao(): Prisma.relatorio_manutencaoDelegate<GlobalReject>;

  /**
   * `prisma.relatorio_operacao`: Exposes CRUD operations for the **relatorio_operacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Relatorio_operacaos
    * const relatorio_operacaos = await prisma.relatorio_operacao.findMany()
    * ```
    */
  get relatorio_operacao(): Prisma.relatorio_operacaoDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.11.0
   * Query Engine version: 8fde8fef4033376662cad983758335009d522acb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    usuario: 'usuario',
    motorista: 'motorista',
    tipo_veiculos: 'tipo_veiculos',
    veiculos: 'veiculos',
    operacoes: 'operacoes',
    manutencao: 'manutencao',
    relatorio_manutencao: 'relatorio_manutencao',
    relatorio_operacao: 'relatorio_operacao'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MotoristaCountOutputType
   */


  export type MotoristaCountOutputType = {
    operacoes: number
  }

  export type MotoristaCountOutputTypeSelect = {
    operacoes?: boolean
  }

  export type MotoristaCountOutputTypeGetPayload<S extends boolean | null | undefined | MotoristaCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MotoristaCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MotoristaCountOutputTypeArgs)
    ? MotoristaCountOutputType 
    : S extends { select: any } & (MotoristaCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MotoristaCountOutputType ? MotoristaCountOutputType[P] : never
  } 
      : MotoristaCountOutputType




  // Custom InputTypes

  /**
   * MotoristaCountOutputType without action
   */
  export type MotoristaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MotoristaCountOutputType
     */
    select?: MotoristaCountOutputTypeSelect | null
  }



  /**
   * Count Type Tipo_veiculosCountOutputType
   */


  export type Tipo_veiculosCountOutputType = {
    veiculos: number
  }

  export type Tipo_veiculosCountOutputTypeSelect = {
    veiculos?: boolean
  }

  export type Tipo_veiculosCountOutputTypeGetPayload<S extends boolean | null | undefined | Tipo_veiculosCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Tipo_veiculosCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Tipo_veiculosCountOutputTypeArgs)
    ? Tipo_veiculosCountOutputType 
    : S extends { select: any } & (Tipo_veiculosCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Tipo_veiculosCountOutputType ? Tipo_veiculosCountOutputType[P] : never
  } 
      : Tipo_veiculosCountOutputType




  // Custom InputTypes

  /**
   * Tipo_veiculosCountOutputType without action
   */
  export type Tipo_veiculosCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Tipo_veiculosCountOutputType
     */
    select?: Tipo_veiculosCountOutputTypeSelect | null
  }



  /**
   * Count Type VeiculosCountOutputType
   */


  export type VeiculosCountOutputType = {
    manutencoes: number
    operacoes: number
  }

  export type VeiculosCountOutputTypeSelect = {
    manutencoes?: boolean
    operacoes?: boolean
  }

  export type VeiculosCountOutputTypeGetPayload<S extends boolean | null | undefined | VeiculosCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VeiculosCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (VeiculosCountOutputTypeArgs)
    ? VeiculosCountOutputType 
    : S extends { select: any } & (VeiculosCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VeiculosCountOutputType ? VeiculosCountOutputType[P] : never
  } 
      : VeiculosCountOutputType




  // Custom InputTypes

  /**
   * VeiculosCountOutputType without action
   */
  export type VeiculosCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VeiculosCountOutputType
     */
    select?: VeiculosCountOutputTypeSelect | null
  }



  /**
   * Count Type OperacoesCountOutputType
   */


  export type OperacoesCountOutputType = {
    relatorios: number
  }

  export type OperacoesCountOutputTypeSelect = {
    relatorios?: boolean
  }

  export type OperacoesCountOutputTypeGetPayload<S extends boolean | null | undefined | OperacoesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OperacoesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OperacoesCountOutputTypeArgs)
    ? OperacoesCountOutputType 
    : S extends { select: any } & (OperacoesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OperacoesCountOutputType ? OperacoesCountOutputType[P] : never
  } 
      : OperacoesCountOutputType




  // Custom InputTypes

  /**
   * OperacoesCountOutputType without action
   */
  export type OperacoesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OperacoesCountOutputType
     */
    select?: OperacoesCountOutputTypeSelect | null
  }



  /**
   * Count Type ManutencaoCountOutputType
   */


  export type ManutencaoCountOutputType = {
    manutencao: number
  }

  export type ManutencaoCountOutputTypeSelect = {
    manutencao?: boolean
  }

  export type ManutencaoCountOutputTypeGetPayload<S extends boolean | null | undefined | ManutencaoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ManutencaoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ManutencaoCountOutputTypeArgs)
    ? ManutencaoCountOutputType 
    : S extends { select: any } & (ManutencaoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ManutencaoCountOutputType ? ManutencaoCountOutputType[P] : never
  } 
      : ManutencaoCountOutputType




  // Custom InputTypes

  /**
   * ManutencaoCountOutputType without action
   */
  export type ManutencaoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ManutencaoCountOutputType
     */
    select?: ManutencaoCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model usuario
   */


  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
    nivel: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
    nivel: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    senha: string | null
    nivel: number | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    senha: string | null
    nivel: number | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    senha: number
    nivel: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
    nivel?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
    nivel?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    nivel?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    nivel?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    nivel?: true
    _all?: true
  }

  export type UsuarioAggregateArgs = {
    /**
     * Filter which usuario to aggregate.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs = {
    where?: usuarioWhereInput
    orderBy?: Enumerable<usuarioOrderByWithAggregationInput>
    by: UsuarioScalarFieldEnum[]
    having?: usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }


  export type UsuarioGroupByOutputType = {
    id: number
    nome: string
    email: string
    senha: string
    nivel: number
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type usuarioSelect = {
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    nivel?: boolean
  }


  export type usuarioGetPayload<S extends boolean | null | undefined | usuarioArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? usuario :
    S extends undefined ? never :
    S extends { include: any } & (usuarioArgs | usuarioFindManyArgs)
    ? usuario 
    : S extends { select: any } & (usuarioArgs | usuarioFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof usuario ? usuario[P] : never
  } 
      : usuario


  type usuarioCountArgs = 
    Omit<usuarioFindManyArgs, 'select' | 'include'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface usuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Usuario that matches the filter.
     * @param {usuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'usuario'> extends True ? Prisma__usuarioClient<usuarioGetPayload<T>> : Prisma__usuarioClient<usuarioGetPayload<T> | null, null>

    /**
     * Find one Usuario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usuarioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usuarioFindUniqueOrThrowArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'usuario'> extends True ? Prisma__usuarioClient<usuarioGetPayload<T>> : Prisma__usuarioClient<usuarioGetPayload<T> | null, null>

    /**
     * Find the first Usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usuarioFindFirstOrThrowArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usuarioFindManyArgs>(
      args?: SelectSubset<T, usuarioFindManyArgs>
    ): Prisma.PrismaPromise<Array<usuarioGetPayload<T>>>

    /**
     * Create a Usuario.
     * @param {usuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends usuarioCreateArgs>(
      args: SelectSubset<T, usuarioCreateArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Create many Usuarios.
     *     @param {usuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usuarioCreateManyArgs>(
      args?: SelectSubset<T, usuarioCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {usuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends usuarioDeleteArgs>(
      args: SelectSubset<T, usuarioDeleteArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Update one Usuario.
     * @param {usuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usuarioUpdateArgs>(
      args: SelectSubset<T, usuarioUpdateArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Delete zero or more Usuarios.
     * @param {usuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usuarioDeleteManyArgs>(
      args?: SelectSubset<T, usuarioDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usuarioUpdateManyArgs>(
      args: SelectSubset<T, usuarioUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {usuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends usuarioUpsertArgs>(
      args: SelectSubset<T, usuarioUpsertArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuarioCountArgs>(
      args?: Subset<T, usuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usuarioClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * usuario base type for findUnique actions
   */
  export type usuarioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario findUnique
   */
  export interface usuarioFindUniqueArgs extends usuarioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario findUniqueOrThrow
   */
  export type usuarioFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario base type for findFirst actions
   */
  export type usuarioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }

  /**
   * usuario findFirst
   */
  export interface usuarioFindFirstArgs extends usuarioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario findFirstOrThrow
   */
  export type usuarioFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * usuario findMany
   */
  export type usuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * usuario create
   */
  export type usuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * The data needed to create a usuario.
     */
    data: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
  }


  /**
   * usuario createMany
   */
  export type usuarioCreateManyArgs = {
    /**
     * The data used to create many usuarios.
     */
    data: Enumerable<usuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * usuario update
   */
  export type usuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * The data needed to update a usuario.
     */
    data: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
    /**
     * Choose, which usuario to update.
     */
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario updateMany
   */
  export type usuarioUpdateManyArgs = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuarioWhereInput
  }


  /**
   * usuario upsert
   */
  export type usuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * The filter to search for the usuario to update in case it exists.
     */
    where: usuarioWhereUniqueInput
    /**
     * In case the usuario found by the `where` argument doesn't exist, create a new usuario with this data.
     */
    create: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
    /**
     * In case the usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
  }


  /**
   * usuario delete
   */
  export type usuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
    /**
     * Filter which usuario to delete.
     */
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario deleteMany
   */
  export type usuarioDeleteManyArgs = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuarioWhereInput
  }


  /**
   * usuario without action
   */
  export type usuarioArgs = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect | null
  }



  /**
   * Model motorista
   */


  export type AggregateMotorista = {
    _count: MotoristaCountAggregateOutputType | null
    _avg: MotoristaAvgAggregateOutputType | null
    _sum: MotoristaSumAggregateOutputType | null
    _min: MotoristaMinAggregateOutputType | null
    _max: MotoristaMaxAggregateOutputType | null
  }

  export type MotoristaAvgAggregateOutputType = {
    id: number | null
  }

  export type MotoristaSumAggregateOutputType = {
    id: number | null
  }

  export type MotoristaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    ocupado: boolean | null
  }

  export type MotoristaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    ocupado: boolean | null
  }

  export type MotoristaCountAggregateOutputType = {
    id: number
    nome: number
    ocupado: number
    _all: number
  }


  export type MotoristaAvgAggregateInputType = {
    id?: true
  }

  export type MotoristaSumAggregateInputType = {
    id?: true
  }

  export type MotoristaMinAggregateInputType = {
    id?: true
    nome?: true
    ocupado?: true
  }

  export type MotoristaMaxAggregateInputType = {
    id?: true
    nome?: true
    ocupado?: true
  }

  export type MotoristaCountAggregateInputType = {
    id?: true
    nome?: true
    ocupado?: true
    _all?: true
  }

  export type MotoristaAggregateArgs = {
    /**
     * Filter which motorista to aggregate.
     */
    where?: motoristaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motoristas to fetch.
     */
    orderBy?: Enumerable<motoristaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: motoristaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motoristas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motoristas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned motoristas
    **/
    _count?: true | MotoristaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MotoristaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MotoristaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MotoristaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MotoristaMaxAggregateInputType
  }

  export type GetMotoristaAggregateType<T extends MotoristaAggregateArgs> = {
        [P in keyof T & keyof AggregateMotorista]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMotorista[P]>
      : GetScalarType<T[P], AggregateMotorista[P]>
  }




  export type MotoristaGroupByArgs = {
    where?: motoristaWhereInput
    orderBy?: Enumerable<motoristaOrderByWithAggregationInput>
    by: MotoristaScalarFieldEnum[]
    having?: motoristaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MotoristaCountAggregateInputType | true
    _avg?: MotoristaAvgAggregateInputType
    _sum?: MotoristaSumAggregateInputType
    _min?: MotoristaMinAggregateInputType
    _max?: MotoristaMaxAggregateInputType
  }


  export type MotoristaGroupByOutputType = {
    id: number
    nome: string
    ocupado: boolean
    _count: MotoristaCountAggregateOutputType | null
    _avg: MotoristaAvgAggregateOutputType | null
    _sum: MotoristaSumAggregateOutputType | null
    _min: MotoristaMinAggregateOutputType | null
    _max: MotoristaMaxAggregateOutputType | null
  }

  type GetMotoristaGroupByPayload<T extends MotoristaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MotoristaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MotoristaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MotoristaGroupByOutputType[P]>
            : GetScalarType<T[P], MotoristaGroupByOutputType[P]>
        }
      >
    >


  export type motoristaSelect = {
    id?: boolean
    nome?: boolean
    ocupado?: boolean
    operacoes?: boolean | motorista$operacoesArgs
    _count?: boolean | MotoristaCountOutputTypeArgs
  }


  export type motoristaInclude = {
    operacoes?: boolean | motorista$operacoesArgs
    _count?: boolean | MotoristaCountOutputTypeArgs
  }

  export type motoristaGetPayload<S extends boolean | null | undefined | motoristaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? motorista :
    S extends undefined ? never :
    S extends { include: any } & (motoristaArgs | motoristaFindManyArgs)
    ? motorista  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'operacoes' ? Array < operacoesGetPayload<S['include'][P]>>  :
        P extends '_count' ? MotoristaCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (motoristaArgs | motoristaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'operacoes' ? Array < operacoesGetPayload<S['select'][P]>>  :
        P extends '_count' ? MotoristaCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof motorista ? motorista[P] : never
  } 
      : motorista


  type motoristaCountArgs = 
    Omit<motoristaFindManyArgs, 'select' | 'include'> & {
      select?: MotoristaCountAggregateInputType | true
    }

  export interface motoristaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Motorista that matches the filter.
     * @param {motoristaFindUniqueArgs} args - Arguments to find a Motorista
     * @example
     * // Get one Motorista
     * const motorista = await prisma.motorista.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends motoristaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, motoristaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'motorista'> extends True ? Prisma__motoristaClient<motoristaGetPayload<T>> : Prisma__motoristaClient<motoristaGetPayload<T> | null, null>

    /**
     * Find one Motorista that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {motoristaFindUniqueOrThrowArgs} args - Arguments to find a Motorista
     * @example
     * // Get one Motorista
     * const motorista = await prisma.motorista.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends motoristaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, motoristaFindUniqueOrThrowArgs>
    ): Prisma__motoristaClient<motoristaGetPayload<T>>

    /**
     * Find the first Motorista that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motoristaFindFirstArgs} args - Arguments to find a Motorista
     * @example
     * // Get one Motorista
     * const motorista = await prisma.motorista.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends motoristaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, motoristaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'motorista'> extends True ? Prisma__motoristaClient<motoristaGetPayload<T>> : Prisma__motoristaClient<motoristaGetPayload<T> | null, null>

    /**
     * Find the first Motorista that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motoristaFindFirstOrThrowArgs} args - Arguments to find a Motorista
     * @example
     * // Get one Motorista
     * const motorista = await prisma.motorista.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends motoristaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, motoristaFindFirstOrThrowArgs>
    ): Prisma__motoristaClient<motoristaGetPayload<T>>

    /**
     * Find zero or more Motoristas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motoristaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Motoristas
     * const motoristas = await prisma.motorista.findMany()
     * 
     * // Get first 10 Motoristas
     * const motoristas = await prisma.motorista.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const motoristaWithIdOnly = await prisma.motorista.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends motoristaFindManyArgs>(
      args?: SelectSubset<T, motoristaFindManyArgs>
    ): Prisma.PrismaPromise<Array<motoristaGetPayload<T>>>

    /**
     * Create a Motorista.
     * @param {motoristaCreateArgs} args - Arguments to create a Motorista.
     * @example
     * // Create one Motorista
     * const Motorista = await prisma.motorista.create({
     *   data: {
     *     // ... data to create a Motorista
     *   }
     * })
     * 
    **/
    create<T extends motoristaCreateArgs>(
      args: SelectSubset<T, motoristaCreateArgs>
    ): Prisma__motoristaClient<motoristaGetPayload<T>>

    /**
     * Create many Motoristas.
     *     @param {motoristaCreateManyArgs} args - Arguments to create many Motoristas.
     *     @example
     *     // Create many Motoristas
     *     const motorista = await prisma.motorista.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends motoristaCreateManyArgs>(
      args?: SelectSubset<T, motoristaCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Motorista.
     * @param {motoristaDeleteArgs} args - Arguments to delete one Motorista.
     * @example
     * // Delete one Motorista
     * const Motorista = await prisma.motorista.delete({
     *   where: {
     *     // ... filter to delete one Motorista
     *   }
     * })
     * 
    **/
    delete<T extends motoristaDeleteArgs>(
      args: SelectSubset<T, motoristaDeleteArgs>
    ): Prisma__motoristaClient<motoristaGetPayload<T>>

    /**
     * Update one Motorista.
     * @param {motoristaUpdateArgs} args - Arguments to update one Motorista.
     * @example
     * // Update one Motorista
     * const motorista = await prisma.motorista.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends motoristaUpdateArgs>(
      args: SelectSubset<T, motoristaUpdateArgs>
    ): Prisma__motoristaClient<motoristaGetPayload<T>>

    /**
     * Delete zero or more Motoristas.
     * @param {motoristaDeleteManyArgs} args - Arguments to filter Motoristas to delete.
     * @example
     * // Delete a few Motoristas
     * const { count } = await prisma.motorista.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends motoristaDeleteManyArgs>(
      args?: SelectSubset<T, motoristaDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motoristas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motoristaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Motoristas
     * const motorista = await prisma.motorista.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends motoristaUpdateManyArgs>(
      args: SelectSubset<T, motoristaUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Motorista.
     * @param {motoristaUpsertArgs} args - Arguments to update or create a Motorista.
     * @example
     * // Update or create a Motorista
     * const motorista = await prisma.motorista.upsert({
     *   create: {
     *     // ... data to create a Motorista
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Motorista we want to update
     *   }
     * })
    **/
    upsert<T extends motoristaUpsertArgs>(
      args: SelectSubset<T, motoristaUpsertArgs>
    ): Prisma__motoristaClient<motoristaGetPayload<T>>

    /**
     * Count the number of Motoristas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {motoristaCountArgs} args - Arguments to filter Motoristas to count.
     * @example
     * // Count the number of Motoristas
     * const count = await prisma.motorista.count({
     *   where: {
     *     // ... the filter for the Motoristas we want to count
     *   }
     * })
    **/
    count<T extends motoristaCountArgs>(
      args?: Subset<T, motoristaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MotoristaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Motorista.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotoristaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MotoristaAggregateArgs>(args: Subset<T, MotoristaAggregateArgs>): Prisma.PrismaPromise<GetMotoristaAggregateType<T>>

    /**
     * Group by Motorista.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotoristaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MotoristaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MotoristaGroupByArgs['orderBy'] }
        : { orderBy?: MotoristaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MotoristaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMotoristaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for motorista.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__motoristaClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    operacoes<T extends motorista$operacoesArgs= {}>(args?: Subset<T, motorista$operacoesArgs>): Prisma.PrismaPromise<Array<operacoesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * motorista base type for findUnique actions
   */
  export type motoristaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the motorista
     */
    select?: motoristaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: motoristaInclude | null
    /**
     * Filter, which motorista to fetch.
     */
    where: motoristaWhereUniqueInput
  }

  /**
   * motorista findUnique
   */
  export interface motoristaFindUniqueArgs extends motoristaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * motorista findUniqueOrThrow
   */
  export type motoristaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the motorista
     */
    select?: motoristaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: motoristaInclude | null
    /**
     * Filter, which motorista to fetch.
     */
    where: motoristaWhereUniqueInput
  }


  /**
   * motorista base type for findFirst actions
   */
  export type motoristaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the motorista
     */
    select?: motoristaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: motoristaInclude | null
    /**
     * Filter, which motorista to fetch.
     */
    where?: motoristaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motoristas to fetch.
     */
    orderBy?: Enumerable<motoristaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for motoristas.
     */
    cursor?: motoristaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motoristas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motoristas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of motoristas.
     */
    distinct?: Enumerable<MotoristaScalarFieldEnum>
  }

  /**
   * motorista findFirst
   */
  export interface motoristaFindFirstArgs extends motoristaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * motorista findFirstOrThrow
   */
  export type motoristaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the motorista
     */
    select?: motoristaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: motoristaInclude | null
    /**
     * Filter, which motorista to fetch.
     */
    where?: motoristaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motoristas to fetch.
     */
    orderBy?: Enumerable<motoristaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for motoristas.
     */
    cursor?: motoristaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motoristas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motoristas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of motoristas.
     */
    distinct?: Enumerable<MotoristaScalarFieldEnum>
  }


  /**
   * motorista findMany
   */
  export type motoristaFindManyArgs = {
    /**
     * Select specific fields to fetch from the motorista
     */
    select?: motoristaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: motoristaInclude | null
    /**
     * Filter, which motoristas to fetch.
     */
    where?: motoristaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of motoristas to fetch.
     */
    orderBy?: Enumerable<motoristaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing motoristas.
     */
    cursor?: motoristaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` motoristas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` motoristas.
     */
    skip?: number
    distinct?: Enumerable<MotoristaScalarFieldEnum>
  }


  /**
   * motorista create
   */
  export type motoristaCreateArgs = {
    /**
     * Select specific fields to fetch from the motorista
     */
    select?: motoristaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: motoristaInclude | null
    /**
     * The data needed to create a motorista.
     */
    data: XOR<motoristaCreateInput, motoristaUncheckedCreateInput>
  }


  /**
   * motorista createMany
   */
  export type motoristaCreateManyArgs = {
    /**
     * The data used to create many motoristas.
     */
    data: Enumerable<motoristaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * motorista update
   */
  export type motoristaUpdateArgs = {
    /**
     * Select specific fields to fetch from the motorista
     */
    select?: motoristaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: motoristaInclude | null
    /**
     * The data needed to update a motorista.
     */
    data: XOR<motoristaUpdateInput, motoristaUncheckedUpdateInput>
    /**
     * Choose, which motorista to update.
     */
    where: motoristaWhereUniqueInput
  }


  /**
   * motorista updateMany
   */
  export type motoristaUpdateManyArgs = {
    /**
     * The data used to update motoristas.
     */
    data: XOR<motoristaUpdateManyMutationInput, motoristaUncheckedUpdateManyInput>
    /**
     * Filter which motoristas to update
     */
    where?: motoristaWhereInput
  }


  /**
   * motorista upsert
   */
  export type motoristaUpsertArgs = {
    /**
     * Select specific fields to fetch from the motorista
     */
    select?: motoristaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: motoristaInclude | null
    /**
     * The filter to search for the motorista to update in case it exists.
     */
    where: motoristaWhereUniqueInput
    /**
     * In case the motorista found by the `where` argument doesn't exist, create a new motorista with this data.
     */
    create: XOR<motoristaCreateInput, motoristaUncheckedCreateInput>
    /**
     * In case the motorista was found with the provided `where` argument, update it with this data.
     */
    update: XOR<motoristaUpdateInput, motoristaUncheckedUpdateInput>
  }


  /**
   * motorista delete
   */
  export type motoristaDeleteArgs = {
    /**
     * Select specific fields to fetch from the motorista
     */
    select?: motoristaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: motoristaInclude | null
    /**
     * Filter which motorista to delete.
     */
    where: motoristaWhereUniqueInput
  }


  /**
   * motorista deleteMany
   */
  export type motoristaDeleteManyArgs = {
    /**
     * Filter which motoristas to delete
     */
    where?: motoristaWhereInput
  }


  /**
   * motorista.operacoes
   */
  export type motorista$operacoesArgs = {
    /**
     * Select specific fields to fetch from the operacoes
     */
    select?: operacoesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operacoesInclude | null
    where?: operacoesWhereInput
    orderBy?: Enumerable<operacoesOrderByWithRelationInput>
    cursor?: operacoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OperacoesScalarFieldEnum>
  }


  /**
   * motorista without action
   */
  export type motoristaArgs = {
    /**
     * Select specific fields to fetch from the motorista
     */
    select?: motoristaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: motoristaInclude | null
  }



  /**
   * Model tipo_veiculos
   */


  export type AggregateTipo_veiculos = {
    _count: Tipo_veiculosCountAggregateOutputType | null
    _avg: Tipo_veiculosAvgAggregateOutputType | null
    _sum: Tipo_veiculosSumAggregateOutputType | null
    _min: Tipo_veiculosMinAggregateOutputType | null
    _max: Tipo_veiculosMaxAggregateOutputType | null
  }

  export type Tipo_veiculosAvgAggregateOutputType = {
    id: number | null
  }

  export type Tipo_veiculosSumAggregateOutputType = {
    id: number | null
  }

  export type Tipo_veiculosMinAggregateOutputType = {
    id: number | null
    tipo: string | null
  }

  export type Tipo_veiculosMaxAggregateOutputType = {
    id: number | null
    tipo: string | null
  }

  export type Tipo_veiculosCountAggregateOutputType = {
    id: number
    tipo: number
    _all: number
  }


  export type Tipo_veiculosAvgAggregateInputType = {
    id?: true
  }

  export type Tipo_veiculosSumAggregateInputType = {
    id?: true
  }

  export type Tipo_veiculosMinAggregateInputType = {
    id?: true
    tipo?: true
  }

  export type Tipo_veiculosMaxAggregateInputType = {
    id?: true
    tipo?: true
  }

  export type Tipo_veiculosCountAggregateInputType = {
    id?: true
    tipo?: true
    _all?: true
  }

  export type Tipo_veiculosAggregateArgs = {
    /**
     * Filter which tipo_veiculos to aggregate.
     */
    where?: tipo_veiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_veiculos to fetch.
     */
    orderBy?: Enumerable<tipo_veiculosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipo_veiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipo_veiculos
    **/
    _count?: true | Tipo_veiculosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tipo_veiculosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tipo_veiculosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tipo_veiculosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tipo_veiculosMaxAggregateInputType
  }

  export type GetTipo_veiculosAggregateType<T extends Tipo_veiculosAggregateArgs> = {
        [P in keyof T & keyof AggregateTipo_veiculos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipo_veiculos[P]>
      : GetScalarType<T[P], AggregateTipo_veiculos[P]>
  }




  export type Tipo_veiculosGroupByArgs = {
    where?: tipo_veiculosWhereInput
    orderBy?: Enumerable<tipo_veiculosOrderByWithAggregationInput>
    by: Tipo_veiculosScalarFieldEnum[]
    having?: tipo_veiculosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tipo_veiculosCountAggregateInputType | true
    _avg?: Tipo_veiculosAvgAggregateInputType
    _sum?: Tipo_veiculosSumAggregateInputType
    _min?: Tipo_veiculosMinAggregateInputType
    _max?: Tipo_veiculosMaxAggregateInputType
  }


  export type Tipo_veiculosGroupByOutputType = {
    id: number
    tipo: string
    _count: Tipo_veiculosCountAggregateOutputType | null
    _avg: Tipo_veiculosAvgAggregateOutputType | null
    _sum: Tipo_veiculosSumAggregateOutputType | null
    _min: Tipo_veiculosMinAggregateOutputType | null
    _max: Tipo_veiculosMaxAggregateOutputType | null
  }

  type GetTipo_veiculosGroupByPayload<T extends Tipo_veiculosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Tipo_veiculosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tipo_veiculosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tipo_veiculosGroupByOutputType[P]>
            : GetScalarType<T[P], Tipo_veiculosGroupByOutputType[P]>
        }
      >
    >


  export type tipo_veiculosSelect = {
    id?: boolean
    tipo?: boolean
    veiculos?: boolean | tipo_veiculos$veiculosArgs
    _count?: boolean | Tipo_veiculosCountOutputTypeArgs
  }


  export type tipo_veiculosInclude = {
    veiculos?: boolean | tipo_veiculos$veiculosArgs
    _count?: boolean | Tipo_veiculosCountOutputTypeArgs
  }

  export type tipo_veiculosGetPayload<S extends boolean | null | undefined | tipo_veiculosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tipo_veiculos :
    S extends undefined ? never :
    S extends { include: any } & (tipo_veiculosArgs | tipo_veiculosFindManyArgs)
    ? tipo_veiculos  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'veiculos' ? Array < veiculosGetPayload<S['include'][P]>>  :
        P extends '_count' ? Tipo_veiculosCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (tipo_veiculosArgs | tipo_veiculosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'veiculos' ? Array < veiculosGetPayload<S['select'][P]>>  :
        P extends '_count' ? Tipo_veiculosCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof tipo_veiculos ? tipo_veiculos[P] : never
  } 
      : tipo_veiculos


  type tipo_veiculosCountArgs = 
    Omit<tipo_veiculosFindManyArgs, 'select' | 'include'> & {
      select?: Tipo_veiculosCountAggregateInputType | true
    }

  export interface tipo_veiculosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tipo_veiculos that matches the filter.
     * @param {tipo_veiculosFindUniqueArgs} args - Arguments to find a Tipo_veiculos
     * @example
     * // Get one Tipo_veiculos
     * const tipo_veiculos = await prisma.tipo_veiculos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tipo_veiculosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tipo_veiculosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tipo_veiculos'> extends True ? Prisma__tipo_veiculosClient<tipo_veiculosGetPayload<T>> : Prisma__tipo_veiculosClient<tipo_veiculosGetPayload<T> | null, null>

    /**
     * Find one Tipo_veiculos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tipo_veiculosFindUniqueOrThrowArgs} args - Arguments to find a Tipo_veiculos
     * @example
     * // Get one Tipo_veiculos
     * const tipo_veiculos = await prisma.tipo_veiculos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tipo_veiculosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tipo_veiculosFindUniqueOrThrowArgs>
    ): Prisma__tipo_veiculosClient<tipo_veiculosGetPayload<T>>

    /**
     * Find the first Tipo_veiculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_veiculosFindFirstArgs} args - Arguments to find a Tipo_veiculos
     * @example
     * // Get one Tipo_veiculos
     * const tipo_veiculos = await prisma.tipo_veiculos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tipo_veiculosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tipo_veiculosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tipo_veiculos'> extends True ? Prisma__tipo_veiculosClient<tipo_veiculosGetPayload<T>> : Prisma__tipo_veiculosClient<tipo_veiculosGetPayload<T> | null, null>

    /**
     * Find the first Tipo_veiculos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_veiculosFindFirstOrThrowArgs} args - Arguments to find a Tipo_veiculos
     * @example
     * // Get one Tipo_veiculos
     * const tipo_veiculos = await prisma.tipo_veiculos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tipo_veiculosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tipo_veiculosFindFirstOrThrowArgs>
    ): Prisma__tipo_veiculosClient<tipo_veiculosGetPayload<T>>

    /**
     * Find zero or more Tipo_veiculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_veiculosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipo_veiculos
     * const tipo_veiculos = await prisma.tipo_veiculos.findMany()
     * 
     * // Get first 10 Tipo_veiculos
     * const tipo_veiculos = await prisma.tipo_veiculos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipo_veiculosWithIdOnly = await prisma.tipo_veiculos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tipo_veiculosFindManyArgs>(
      args?: SelectSubset<T, tipo_veiculosFindManyArgs>
    ): Prisma.PrismaPromise<Array<tipo_veiculosGetPayload<T>>>

    /**
     * Create a Tipo_veiculos.
     * @param {tipo_veiculosCreateArgs} args - Arguments to create a Tipo_veiculos.
     * @example
     * // Create one Tipo_veiculos
     * const Tipo_veiculos = await prisma.tipo_veiculos.create({
     *   data: {
     *     // ... data to create a Tipo_veiculos
     *   }
     * })
     * 
    **/
    create<T extends tipo_veiculosCreateArgs>(
      args: SelectSubset<T, tipo_veiculosCreateArgs>
    ): Prisma__tipo_veiculosClient<tipo_veiculosGetPayload<T>>

    /**
     * Create many Tipo_veiculos.
     *     @param {tipo_veiculosCreateManyArgs} args - Arguments to create many Tipo_veiculos.
     *     @example
     *     // Create many Tipo_veiculos
     *     const tipo_veiculos = await prisma.tipo_veiculos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tipo_veiculosCreateManyArgs>(
      args?: SelectSubset<T, tipo_veiculosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipo_veiculos.
     * @param {tipo_veiculosDeleteArgs} args - Arguments to delete one Tipo_veiculos.
     * @example
     * // Delete one Tipo_veiculos
     * const Tipo_veiculos = await prisma.tipo_veiculos.delete({
     *   where: {
     *     // ... filter to delete one Tipo_veiculos
     *   }
     * })
     * 
    **/
    delete<T extends tipo_veiculosDeleteArgs>(
      args: SelectSubset<T, tipo_veiculosDeleteArgs>
    ): Prisma__tipo_veiculosClient<tipo_veiculosGetPayload<T>>

    /**
     * Update one Tipo_veiculos.
     * @param {tipo_veiculosUpdateArgs} args - Arguments to update one Tipo_veiculos.
     * @example
     * // Update one Tipo_veiculos
     * const tipo_veiculos = await prisma.tipo_veiculos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tipo_veiculosUpdateArgs>(
      args: SelectSubset<T, tipo_veiculosUpdateArgs>
    ): Prisma__tipo_veiculosClient<tipo_veiculosGetPayload<T>>

    /**
     * Delete zero or more Tipo_veiculos.
     * @param {tipo_veiculosDeleteManyArgs} args - Arguments to filter Tipo_veiculos to delete.
     * @example
     * // Delete a few Tipo_veiculos
     * const { count } = await prisma.tipo_veiculos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tipo_veiculosDeleteManyArgs>(
      args?: SelectSubset<T, tipo_veiculosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipo_veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_veiculosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipo_veiculos
     * const tipo_veiculos = await prisma.tipo_veiculos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tipo_veiculosUpdateManyArgs>(
      args: SelectSubset<T, tipo_veiculosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipo_veiculos.
     * @param {tipo_veiculosUpsertArgs} args - Arguments to update or create a Tipo_veiculos.
     * @example
     * // Update or create a Tipo_veiculos
     * const tipo_veiculos = await prisma.tipo_veiculos.upsert({
     *   create: {
     *     // ... data to create a Tipo_veiculos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipo_veiculos we want to update
     *   }
     * })
    **/
    upsert<T extends tipo_veiculosUpsertArgs>(
      args: SelectSubset<T, tipo_veiculosUpsertArgs>
    ): Prisma__tipo_veiculosClient<tipo_veiculosGetPayload<T>>

    /**
     * Count the number of Tipo_veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipo_veiculosCountArgs} args - Arguments to filter Tipo_veiculos to count.
     * @example
     * // Count the number of Tipo_veiculos
     * const count = await prisma.tipo_veiculos.count({
     *   where: {
     *     // ... the filter for the Tipo_veiculos we want to count
     *   }
     * })
    **/
    count<T extends tipo_veiculosCountArgs>(
      args?: Subset<T, tipo_veiculosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tipo_veiculosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipo_veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_veiculosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tipo_veiculosAggregateArgs>(args: Subset<T, Tipo_veiculosAggregateArgs>): Prisma.PrismaPromise<GetTipo_veiculosAggregateType<T>>

    /**
     * Group by Tipo_veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tipo_veiculosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tipo_veiculosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tipo_veiculosGroupByArgs['orderBy'] }
        : { orderBy?: Tipo_veiculosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tipo_veiculosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipo_veiculosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tipo_veiculos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tipo_veiculosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    veiculos<T extends tipo_veiculos$veiculosArgs= {}>(args?: Subset<T, tipo_veiculos$veiculosArgs>): Prisma.PrismaPromise<Array<veiculosGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tipo_veiculos base type for findUnique actions
   */
  export type tipo_veiculosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tipo_veiculos
     */
    select?: tipo_veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipo_veiculosInclude | null
    /**
     * Filter, which tipo_veiculos to fetch.
     */
    where: tipo_veiculosWhereUniqueInput
  }

  /**
   * tipo_veiculos findUnique
   */
  export interface tipo_veiculosFindUniqueArgs extends tipo_veiculosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tipo_veiculos findUniqueOrThrow
   */
  export type tipo_veiculosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tipo_veiculos
     */
    select?: tipo_veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipo_veiculosInclude | null
    /**
     * Filter, which tipo_veiculos to fetch.
     */
    where: tipo_veiculosWhereUniqueInput
  }


  /**
   * tipo_veiculos base type for findFirst actions
   */
  export type tipo_veiculosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tipo_veiculos
     */
    select?: tipo_veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipo_veiculosInclude | null
    /**
     * Filter, which tipo_veiculos to fetch.
     */
    where?: tipo_veiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_veiculos to fetch.
     */
    orderBy?: Enumerable<tipo_veiculosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipo_veiculos.
     */
    cursor?: tipo_veiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipo_veiculos.
     */
    distinct?: Enumerable<Tipo_veiculosScalarFieldEnum>
  }

  /**
   * tipo_veiculos findFirst
   */
  export interface tipo_veiculosFindFirstArgs extends tipo_veiculosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tipo_veiculos findFirstOrThrow
   */
  export type tipo_veiculosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tipo_veiculos
     */
    select?: tipo_veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipo_veiculosInclude | null
    /**
     * Filter, which tipo_veiculos to fetch.
     */
    where?: tipo_veiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_veiculos to fetch.
     */
    orderBy?: Enumerable<tipo_veiculosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipo_veiculos.
     */
    cursor?: tipo_veiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipo_veiculos.
     */
    distinct?: Enumerable<Tipo_veiculosScalarFieldEnum>
  }


  /**
   * tipo_veiculos findMany
   */
  export type tipo_veiculosFindManyArgs = {
    /**
     * Select specific fields to fetch from the tipo_veiculos
     */
    select?: tipo_veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipo_veiculosInclude | null
    /**
     * Filter, which tipo_veiculos to fetch.
     */
    where?: tipo_veiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipo_veiculos to fetch.
     */
    orderBy?: Enumerable<tipo_veiculosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipo_veiculos.
     */
    cursor?: tipo_veiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipo_veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipo_veiculos.
     */
    skip?: number
    distinct?: Enumerable<Tipo_veiculosScalarFieldEnum>
  }


  /**
   * tipo_veiculos create
   */
  export type tipo_veiculosCreateArgs = {
    /**
     * Select specific fields to fetch from the tipo_veiculos
     */
    select?: tipo_veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipo_veiculosInclude | null
    /**
     * The data needed to create a tipo_veiculos.
     */
    data: XOR<tipo_veiculosCreateInput, tipo_veiculosUncheckedCreateInput>
  }


  /**
   * tipo_veiculos createMany
   */
  export type tipo_veiculosCreateManyArgs = {
    /**
     * The data used to create many tipo_veiculos.
     */
    data: Enumerable<tipo_veiculosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tipo_veiculos update
   */
  export type tipo_veiculosUpdateArgs = {
    /**
     * Select specific fields to fetch from the tipo_veiculos
     */
    select?: tipo_veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipo_veiculosInclude | null
    /**
     * The data needed to update a tipo_veiculos.
     */
    data: XOR<tipo_veiculosUpdateInput, tipo_veiculosUncheckedUpdateInput>
    /**
     * Choose, which tipo_veiculos to update.
     */
    where: tipo_veiculosWhereUniqueInput
  }


  /**
   * tipo_veiculos updateMany
   */
  export type tipo_veiculosUpdateManyArgs = {
    /**
     * The data used to update tipo_veiculos.
     */
    data: XOR<tipo_veiculosUpdateManyMutationInput, tipo_veiculosUncheckedUpdateManyInput>
    /**
     * Filter which tipo_veiculos to update
     */
    where?: tipo_veiculosWhereInput
  }


  /**
   * tipo_veiculos upsert
   */
  export type tipo_veiculosUpsertArgs = {
    /**
     * Select specific fields to fetch from the tipo_veiculos
     */
    select?: tipo_veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipo_veiculosInclude | null
    /**
     * The filter to search for the tipo_veiculos to update in case it exists.
     */
    where: tipo_veiculosWhereUniqueInput
    /**
     * In case the tipo_veiculos found by the `where` argument doesn't exist, create a new tipo_veiculos with this data.
     */
    create: XOR<tipo_veiculosCreateInput, tipo_veiculosUncheckedCreateInput>
    /**
     * In case the tipo_veiculos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipo_veiculosUpdateInput, tipo_veiculosUncheckedUpdateInput>
  }


  /**
   * tipo_veiculos delete
   */
  export type tipo_veiculosDeleteArgs = {
    /**
     * Select specific fields to fetch from the tipo_veiculos
     */
    select?: tipo_veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipo_veiculosInclude | null
    /**
     * Filter which tipo_veiculos to delete.
     */
    where: tipo_veiculosWhereUniqueInput
  }


  /**
   * tipo_veiculos deleteMany
   */
  export type tipo_veiculosDeleteManyArgs = {
    /**
     * Filter which tipo_veiculos to delete
     */
    where?: tipo_veiculosWhereInput
  }


  /**
   * tipo_veiculos.veiculos
   */
  export type tipo_veiculos$veiculosArgs = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculosInclude | null
    where?: veiculosWhereInput
    orderBy?: Enumerable<veiculosOrderByWithRelationInput>
    cursor?: veiculosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VeiculosScalarFieldEnum>
  }


  /**
   * tipo_veiculos without action
   */
  export type tipo_veiculosArgs = {
    /**
     * Select specific fields to fetch from the tipo_veiculos
     */
    select?: tipo_veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tipo_veiculosInclude | null
  }



  /**
   * Model veiculos
   */


  export type AggregateVeiculos = {
    _count: VeiculosCountAggregateOutputType | null
    _avg: VeiculosAvgAggregateOutputType | null
    _sum: VeiculosSumAggregateOutputType | null
    _min: VeiculosMinAggregateOutputType | null
    _max: VeiculosMaxAggregateOutputType | null
  }

  export type VeiculosAvgAggregateOutputType = {
    id: number | null
    tipo: number | null
  }

  export type VeiculosSumAggregateOutputType = {
    id: number | null
    tipo: number | null
  }

  export type VeiculosMinAggregateOutputType = {
    id: number | null
    placa: string | null
    tipo: number | null
    uso: boolean | null
  }

  export type VeiculosMaxAggregateOutputType = {
    id: number | null
    placa: string | null
    tipo: number | null
    uso: boolean | null
  }

  export type VeiculosCountAggregateOutputType = {
    id: number
    placa: number
    tipo: number
    uso: number
    _all: number
  }


  export type VeiculosAvgAggregateInputType = {
    id?: true
    tipo?: true
  }

  export type VeiculosSumAggregateInputType = {
    id?: true
    tipo?: true
  }

  export type VeiculosMinAggregateInputType = {
    id?: true
    placa?: true
    tipo?: true
    uso?: true
  }

  export type VeiculosMaxAggregateInputType = {
    id?: true
    placa?: true
    tipo?: true
    uso?: true
  }

  export type VeiculosCountAggregateInputType = {
    id?: true
    placa?: true
    tipo?: true
    uso?: true
    _all?: true
  }

  export type VeiculosAggregateArgs = {
    /**
     * Filter which veiculos to aggregate.
     */
    where?: veiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veiculos to fetch.
     */
    orderBy?: Enumerable<veiculosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: veiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned veiculos
    **/
    _count?: true | VeiculosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VeiculosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VeiculosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VeiculosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VeiculosMaxAggregateInputType
  }

  export type GetVeiculosAggregateType<T extends VeiculosAggregateArgs> = {
        [P in keyof T & keyof AggregateVeiculos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVeiculos[P]>
      : GetScalarType<T[P], AggregateVeiculos[P]>
  }




  export type VeiculosGroupByArgs = {
    where?: veiculosWhereInput
    orderBy?: Enumerable<veiculosOrderByWithAggregationInput>
    by: VeiculosScalarFieldEnum[]
    having?: veiculosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VeiculosCountAggregateInputType | true
    _avg?: VeiculosAvgAggregateInputType
    _sum?: VeiculosSumAggregateInputType
    _min?: VeiculosMinAggregateInputType
    _max?: VeiculosMaxAggregateInputType
  }


  export type VeiculosGroupByOutputType = {
    id: number
    placa: string
    tipo: number
    uso: boolean
    _count: VeiculosCountAggregateOutputType | null
    _avg: VeiculosAvgAggregateOutputType | null
    _sum: VeiculosSumAggregateOutputType | null
    _min: VeiculosMinAggregateOutputType | null
    _max: VeiculosMaxAggregateOutputType | null
  }

  type GetVeiculosGroupByPayload<T extends VeiculosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VeiculosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VeiculosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VeiculosGroupByOutputType[P]>
            : GetScalarType<T[P], VeiculosGroupByOutputType[P]>
        }
      >
    >


  export type veiculosSelect = {
    id?: boolean
    placa?: boolean
    tipo?: boolean
    uso?: boolean
    manutencoes?: boolean | veiculos$manutencoesArgs
    operacoes?: boolean | veiculos$operacoesArgs
    tipos?: boolean | tipo_veiculosArgs
    _count?: boolean | VeiculosCountOutputTypeArgs
  }


  export type veiculosInclude = {
    manutencoes?: boolean | veiculos$manutencoesArgs
    operacoes?: boolean | veiculos$operacoesArgs
    tipos?: boolean | tipo_veiculosArgs
    _count?: boolean | VeiculosCountOutputTypeArgs
  }

  export type veiculosGetPayload<S extends boolean | null | undefined | veiculosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? veiculos :
    S extends undefined ? never :
    S extends { include: any } & (veiculosArgs | veiculosFindManyArgs)
    ? veiculos  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'manutencoes' ? Array < manutencaoGetPayload<S['include'][P]>>  :
        P extends 'operacoes' ? Array < operacoesGetPayload<S['include'][P]>>  :
        P extends 'tipos' ? tipo_veiculosGetPayload<S['include'][P]> :
        P extends '_count' ? VeiculosCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (veiculosArgs | veiculosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'manutencoes' ? Array < manutencaoGetPayload<S['select'][P]>>  :
        P extends 'operacoes' ? Array < operacoesGetPayload<S['select'][P]>>  :
        P extends 'tipos' ? tipo_veiculosGetPayload<S['select'][P]> :
        P extends '_count' ? VeiculosCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof veiculos ? veiculos[P] : never
  } 
      : veiculos


  type veiculosCountArgs = 
    Omit<veiculosFindManyArgs, 'select' | 'include'> & {
      select?: VeiculosCountAggregateInputType | true
    }

  export interface veiculosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Veiculos that matches the filter.
     * @param {veiculosFindUniqueArgs} args - Arguments to find a Veiculos
     * @example
     * // Get one Veiculos
     * const veiculos = await prisma.veiculos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends veiculosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, veiculosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'veiculos'> extends True ? Prisma__veiculosClient<veiculosGetPayload<T>> : Prisma__veiculosClient<veiculosGetPayload<T> | null, null>

    /**
     * Find one Veiculos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {veiculosFindUniqueOrThrowArgs} args - Arguments to find a Veiculos
     * @example
     * // Get one Veiculos
     * const veiculos = await prisma.veiculos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends veiculosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, veiculosFindUniqueOrThrowArgs>
    ): Prisma__veiculosClient<veiculosGetPayload<T>>

    /**
     * Find the first Veiculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculosFindFirstArgs} args - Arguments to find a Veiculos
     * @example
     * // Get one Veiculos
     * const veiculos = await prisma.veiculos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends veiculosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, veiculosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'veiculos'> extends True ? Prisma__veiculosClient<veiculosGetPayload<T>> : Prisma__veiculosClient<veiculosGetPayload<T> | null, null>

    /**
     * Find the first Veiculos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculosFindFirstOrThrowArgs} args - Arguments to find a Veiculos
     * @example
     * // Get one Veiculos
     * const veiculos = await prisma.veiculos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends veiculosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, veiculosFindFirstOrThrowArgs>
    ): Prisma__veiculosClient<veiculosGetPayload<T>>

    /**
     * Find zero or more Veiculos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Veiculos
     * const veiculos = await prisma.veiculos.findMany()
     * 
     * // Get first 10 Veiculos
     * const veiculos = await prisma.veiculos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const veiculosWithIdOnly = await prisma.veiculos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends veiculosFindManyArgs>(
      args?: SelectSubset<T, veiculosFindManyArgs>
    ): Prisma.PrismaPromise<Array<veiculosGetPayload<T>>>

    /**
     * Create a Veiculos.
     * @param {veiculosCreateArgs} args - Arguments to create a Veiculos.
     * @example
     * // Create one Veiculos
     * const Veiculos = await prisma.veiculos.create({
     *   data: {
     *     // ... data to create a Veiculos
     *   }
     * })
     * 
    **/
    create<T extends veiculosCreateArgs>(
      args: SelectSubset<T, veiculosCreateArgs>
    ): Prisma__veiculosClient<veiculosGetPayload<T>>

    /**
     * Create many Veiculos.
     *     @param {veiculosCreateManyArgs} args - Arguments to create many Veiculos.
     *     @example
     *     // Create many Veiculos
     *     const veiculos = await prisma.veiculos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends veiculosCreateManyArgs>(
      args?: SelectSubset<T, veiculosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Veiculos.
     * @param {veiculosDeleteArgs} args - Arguments to delete one Veiculos.
     * @example
     * // Delete one Veiculos
     * const Veiculos = await prisma.veiculos.delete({
     *   where: {
     *     // ... filter to delete one Veiculos
     *   }
     * })
     * 
    **/
    delete<T extends veiculosDeleteArgs>(
      args: SelectSubset<T, veiculosDeleteArgs>
    ): Prisma__veiculosClient<veiculosGetPayload<T>>

    /**
     * Update one Veiculos.
     * @param {veiculosUpdateArgs} args - Arguments to update one Veiculos.
     * @example
     * // Update one Veiculos
     * const veiculos = await prisma.veiculos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends veiculosUpdateArgs>(
      args: SelectSubset<T, veiculosUpdateArgs>
    ): Prisma__veiculosClient<veiculosGetPayload<T>>

    /**
     * Delete zero or more Veiculos.
     * @param {veiculosDeleteManyArgs} args - Arguments to filter Veiculos to delete.
     * @example
     * // Delete a few Veiculos
     * const { count } = await prisma.veiculos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends veiculosDeleteManyArgs>(
      args?: SelectSubset<T, veiculosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Veiculos
     * const veiculos = await prisma.veiculos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends veiculosUpdateManyArgs>(
      args: SelectSubset<T, veiculosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Veiculos.
     * @param {veiculosUpsertArgs} args - Arguments to update or create a Veiculos.
     * @example
     * // Update or create a Veiculos
     * const veiculos = await prisma.veiculos.upsert({
     *   create: {
     *     // ... data to create a Veiculos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Veiculos we want to update
     *   }
     * })
    **/
    upsert<T extends veiculosUpsertArgs>(
      args: SelectSubset<T, veiculosUpsertArgs>
    ): Prisma__veiculosClient<veiculosGetPayload<T>>

    /**
     * Count the number of Veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculosCountArgs} args - Arguments to filter Veiculos to count.
     * @example
     * // Count the number of Veiculos
     * const count = await prisma.veiculos.count({
     *   where: {
     *     // ... the filter for the Veiculos we want to count
     *   }
     * })
    **/
    count<T extends veiculosCountArgs>(
      args?: Subset<T, veiculosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VeiculosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VeiculosAggregateArgs>(args: Subset<T, VeiculosAggregateArgs>): Prisma.PrismaPromise<GetVeiculosAggregateType<T>>

    /**
     * Group by Veiculos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VeiculosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VeiculosGroupByArgs['orderBy'] }
        : { orderBy?: VeiculosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VeiculosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVeiculosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for veiculos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__veiculosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    manutencoes<T extends veiculos$manutencoesArgs= {}>(args?: Subset<T, veiculos$manutencoesArgs>): Prisma.PrismaPromise<Array<manutencaoGetPayload<T>>| Null>;

    operacoes<T extends veiculos$operacoesArgs= {}>(args?: Subset<T, veiculos$operacoesArgs>): Prisma.PrismaPromise<Array<operacoesGetPayload<T>>| Null>;

    tipos<T extends tipo_veiculosArgs= {}>(args?: Subset<T, tipo_veiculosArgs>): Prisma__tipo_veiculosClient<tipo_veiculosGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * veiculos base type for findUnique actions
   */
  export type veiculosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculosInclude | null
    /**
     * Filter, which veiculos to fetch.
     */
    where: veiculosWhereUniqueInput
  }

  /**
   * veiculos findUnique
   */
  export interface veiculosFindUniqueArgs extends veiculosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * veiculos findUniqueOrThrow
   */
  export type veiculosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculosInclude | null
    /**
     * Filter, which veiculos to fetch.
     */
    where: veiculosWhereUniqueInput
  }


  /**
   * veiculos base type for findFirst actions
   */
  export type veiculosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculosInclude | null
    /**
     * Filter, which veiculos to fetch.
     */
    where?: veiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veiculos to fetch.
     */
    orderBy?: Enumerable<veiculosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for veiculos.
     */
    cursor?: veiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of veiculos.
     */
    distinct?: Enumerable<VeiculosScalarFieldEnum>
  }

  /**
   * veiculos findFirst
   */
  export interface veiculosFindFirstArgs extends veiculosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * veiculos findFirstOrThrow
   */
  export type veiculosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculosInclude | null
    /**
     * Filter, which veiculos to fetch.
     */
    where?: veiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veiculos to fetch.
     */
    orderBy?: Enumerable<veiculosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for veiculos.
     */
    cursor?: veiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veiculos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of veiculos.
     */
    distinct?: Enumerable<VeiculosScalarFieldEnum>
  }


  /**
   * veiculos findMany
   */
  export type veiculosFindManyArgs = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculosInclude | null
    /**
     * Filter, which veiculos to fetch.
     */
    where?: veiculosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veiculos to fetch.
     */
    orderBy?: Enumerable<veiculosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing veiculos.
     */
    cursor?: veiculosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veiculos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veiculos.
     */
    skip?: number
    distinct?: Enumerable<VeiculosScalarFieldEnum>
  }


  /**
   * veiculos create
   */
  export type veiculosCreateArgs = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculosInclude | null
    /**
     * The data needed to create a veiculos.
     */
    data: XOR<veiculosCreateInput, veiculosUncheckedCreateInput>
  }


  /**
   * veiculos createMany
   */
  export type veiculosCreateManyArgs = {
    /**
     * The data used to create many veiculos.
     */
    data: Enumerable<veiculosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * veiculos update
   */
  export type veiculosUpdateArgs = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculosInclude | null
    /**
     * The data needed to update a veiculos.
     */
    data: XOR<veiculosUpdateInput, veiculosUncheckedUpdateInput>
    /**
     * Choose, which veiculos to update.
     */
    where: veiculosWhereUniqueInput
  }


  /**
   * veiculos updateMany
   */
  export type veiculosUpdateManyArgs = {
    /**
     * The data used to update veiculos.
     */
    data: XOR<veiculosUpdateManyMutationInput, veiculosUncheckedUpdateManyInput>
    /**
     * Filter which veiculos to update
     */
    where?: veiculosWhereInput
  }


  /**
   * veiculos upsert
   */
  export type veiculosUpsertArgs = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculosInclude | null
    /**
     * The filter to search for the veiculos to update in case it exists.
     */
    where: veiculosWhereUniqueInput
    /**
     * In case the veiculos found by the `where` argument doesn't exist, create a new veiculos with this data.
     */
    create: XOR<veiculosCreateInput, veiculosUncheckedCreateInput>
    /**
     * In case the veiculos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<veiculosUpdateInput, veiculosUncheckedUpdateInput>
  }


  /**
   * veiculos delete
   */
  export type veiculosDeleteArgs = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculosInclude | null
    /**
     * Filter which veiculos to delete.
     */
    where: veiculosWhereUniqueInput
  }


  /**
   * veiculos deleteMany
   */
  export type veiculosDeleteManyArgs = {
    /**
     * Filter which veiculos to delete
     */
    where?: veiculosWhereInput
  }


  /**
   * veiculos.manutencoes
   */
  export type veiculos$manutencoesArgs = {
    /**
     * Select specific fields to fetch from the manutencao
     */
    select?: manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manutencaoInclude | null
    where?: manutencaoWhereInput
    orderBy?: Enumerable<manutencaoOrderByWithRelationInput>
    cursor?: manutencaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ManutencaoScalarFieldEnum>
  }


  /**
   * veiculos.operacoes
   */
  export type veiculos$operacoesArgs = {
    /**
     * Select specific fields to fetch from the operacoes
     */
    select?: operacoesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operacoesInclude | null
    where?: operacoesWhereInput
    orderBy?: Enumerable<operacoesOrderByWithRelationInput>
    cursor?: operacoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OperacoesScalarFieldEnum>
  }


  /**
   * veiculos without action
   */
  export type veiculosArgs = {
    /**
     * Select specific fields to fetch from the veiculos
     */
    select?: veiculosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculosInclude | null
  }



  /**
   * Model operacoes
   */


  export type AggregateOperacoes = {
    _count: OperacoesCountAggregateOutputType | null
    _avg: OperacoesAvgAggregateOutputType | null
    _sum: OperacoesSumAggregateOutputType | null
    _min: OperacoesMinAggregateOutputType | null
    _max: OperacoesMaxAggregateOutputType | null
  }

  export type OperacoesAvgAggregateOutputType = {
    id: number | null
    veiculo: number | null
    motorista: number | null
  }

  export type OperacoesSumAggregateOutputType = {
    id: number | null
    veiculo: number | null
    motorista: number | null
  }

  export type OperacoesMinAggregateOutputType = {
    id: number | null
    veiculo: number | null
    motorista: number | null
    data_saida: Date | null
    descricao: string | null
    data_retorno: Date | null
    concluidas: boolean | null
  }

  export type OperacoesMaxAggregateOutputType = {
    id: number | null
    veiculo: number | null
    motorista: number | null
    data_saida: Date | null
    descricao: string | null
    data_retorno: Date | null
    concluidas: boolean | null
  }

  export type OperacoesCountAggregateOutputType = {
    id: number
    veiculo: number
    motorista: number
    data_saida: number
    descricao: number
    data_retorno: number
    concluidas: number
    _all: number
  }


  export type OperacoesAvgAggregateInputType = {
    id?: true
    veiculo?: true
    motorista?: true
  }

  export type OperacoesSumAggregateInputType = {
    id?: true
    veiculo?: true
    motorista?: true
  }

  export type OperacoesMinAggregateInputType = {
    id?: true
    veiculo?: true
    motorista?: true
    data_saida?: true
    descricao?: true
    data_retorno?: true
    concluidas?: true
  }

  export type OperacoesMaxAggregateInputType = {
    id?: true
    veiculo?: true
    motorista?: true
    data_saida?: true
    descricao?: true
    data_retorno?: true
    concluidas?: true
  }

  export type OperacoesCountAggregateInputType = {
    id?: true
    veiculo?: true
    motorista?: true
    data_saida?: true
    descricao?: true
    data_retorno?: true
    concluidas?: true
    _all?: true
  }

  export type OperacoesAggregateArgs = {
    /**
     * Filter which operacoes to aggregate.
     */
    where?: operacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operacoes to fetch.
     */
    orderBy?: Enumerable<operacoesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: operacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned operacoes
    **/
    _count?: true | OperacoesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperacoesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperacoesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperacoesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperacoesMaxAggregateInputType
  }

  export type GetOperacoesAggregateType<T extends OperacoesAggregateArgs> = {
        [P in keyof T & keyof AggregateOperacoes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperacoes[P]>
      : GetScalarType<T[P], AggregateOperacoes[P]>
  }




  export type OperacoesGroupByArgs = {
    where?: operacoesWhereInput
    orderBy?: Enumerable<operacoesOrderByWithAggregationInput>
    by: OperacoesScalarFieldEnum[]
    having?: operacoesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperacoesCountAggregateInputType | true
    _avg?: OperacoesAvgAggregateInputType
    _sum?: OperacoesSumAggregateInputType
    _min?: OperacoesMinAggregateInputType
    _max?: OperacoesMaxAggregateInputType
  }


  export type OperacoesGroupByOutputType = {
    id: number
    veiculo: number
    motorista: number
    data_saida: Date
    descricao: string
    data_retorno: Date | null
    concluidas: boolean
    _count: OperacoesCountAggregateOutputType | null
    _avg: OperacoesAvgAggregateOutputType | null
    _sum: OperacoesSumAggregateOutputType | null
    _min: OperacoesMinAggregateOutputType | null
    _max: OperacoesMaxAggregateOutputType | null
  }

  type GetOperacoesGroupByPayload<T extends OperacoesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OperacoesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperacoesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperacoesGroupByOutputType[P]>
            : GetScalarType<T[P], OperacoesGroupByOutputType[P]>
        }
      >
    >


  export type operacoesSelect = {
    id?: boolean
    veiculo?: boolean
    motorista?: boolean
    data_saida?: boolean
    descricao?: boolean
    data_retorno?: boolean
    concluidas?: boolean
    relatorios?: boolean | operacoes$relatoriosArgs
    tipos?: boolean | veiculosArgs
    motoristas?: boolean | motoristaArgs
    _count?: boolean | OperacoesCountOutputTypeArgs
  }


  export type operacoesInclude = {
    relatorios?: boolean | operacoes$relatoriosArgs
    tipos?: boolean | veiculosArgs
    motoristas?: boolean | motoristaArgs
    _count?: boolean | OperacoesCountOutputTypeArgs
  }

  export type operacoesGetPayload<S extends boolean | null | undefined | operacoesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? operacoes :
    S extends undefined ? never :
    S extends { include: any } & (operacoesArgs | operacoesFindManyArgs)
    ? operacoes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'relatorios' ? Array < relatorio_operacaoGetPayload<S['include'][P]>>  :
        P extends 'tipos' ? veiculosGetPayload<S['include'][P]> :
        P extends 'motoristas' ? motoristaGetPayload<S['include'][P]> :
        P extends '_count' ? OperacoesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (operacoesArgs | operacoesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'relatorios' ? Array < relatorio_operacaoGetPayload<S['select'][P]>>  :
        P extends 'tipos' ? veiculosGetPayload<S['select'][P]> :
        P extends 'motoristas' ? motoristaGetPayload<S['select'][P]> :
        P extends '_count' ? OperacoesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof operacoes ? operacoes[P] : never
  } 
      : operacoes


  type operacoesCountArgs = 
    Omit<operacoesFindManyArgs, 'select' | 'include'> & {
      select?: OperacoesCountAggregateInputType | true
    }

  export interface operacoesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Operacoes that matches the filter.
     * @param {operacoesFindUniqueArgs} args - Arguments to find a Operacoes
     * @example
     * // Get one Operacoes
     * const operacoes = await prisma.operacoes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends operacoesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, operacoesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'operacoes'> extends True ? Prisma__operacoesClient<operacoesGetPayload<T>> : Prisma__operacoesClient<operacoesGetPayload<T> | null, null>

    /**
     * Find one Operacoes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {operacoesFindUniqueOrThrowArgs} args - Arguments to find a Operacoes
     * @example
     * // Get one Operacoes
     * const operacoes = await prisma.operacoes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends operacoesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, operacoesFindUniqueOrThrowArgs>
    ): Prisma__operacoesClient<operacoesGetPayload<T>>

    /**
     * Find the first Operacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operacoesFindFirstArgs} args - Arguments to find a Operacoes
     * @example
     * // Get one Operacoes
     * const operacoes = await prisma.operacoes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends operacoesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, operacoesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'operacoes'> extends True ? Prisma__operacoesClient<operacoesGetPayload<T>> : Prisma__operacoesClient<operacoesGetPayload<T> | null, null>

    /**
     * Find the first Operacoes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operacoesFindFirstOrThrowArgs} args - Arguments to find a Operacoes
     * @example
     * // Get one Operacoes
     * const operacoes = await prisma.operacoes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends operacoesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, operacoesFindFirstOrThrowArgs>
    ): Prisma__operacoesClient<operacoesGetPayload<T>>

    /**
     * Find zero or more Operacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operacoesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operacoes
     * const operacoes = await prisma.operacoes.findMany()
     * 
     * // Get first 10 Operacoes
     * const operacoes = await prisma.operacoes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operacoesWithIdOnly = await prisma.operacoes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends operacoesFindManyArgs>(
      args?: SelectSubset<T, operacoesFindManyArgs>
    ): Prisma.PrismaPromise<Array<operacoesGetPayload<T>>>

    /**
     * Create a Operacoes.
     * @param {operacoesCreateArgs} args - Arguments to create a Operacoes.
     * @example
     * // Create one Operacoes
     * const Operacoes = await prisma.operacoes.create({
     *   data: {
     *     // ... data to create a Operacoes
     *   }
     * })
     * 
    **/
    create<T extends operacoesCreateArgs>(
      args: SelectSubset<T, operacoesCreateArgs>
    ): Prisma__operacoesClient<operacoesGetPayload<T>>

    /**
     * Create many Operacoes.
     *     @param {operacoesCreateManyArgs} args - Arguments to create many Operacoes.
     *     @example
     *     // Create many Operacoes
     *     const operacoes = await prisma.operacoes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends operacoesCreateManyArgs>(
      args?: SelectSubset<T, operacoesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Operacoes.
     * @param {operacoesDeleteArgs} args - Arguments to delete one Operacoes.
     * @example
     * // Delete one Operacoes
     * const Operacoes = await prisma.operacoes.delete({
     *   where: {
     *     // ... filter to delete one Operacoes
     *   }
     * })
     * 
    **/
    delete<T extends operacoesDeleteArgs>(
      args: SelectSubset<T, operacoesDeleteArgs>
    ): Prisma__operacoesClient<operacoesGetPayload<T>>

    /**
     * Update one Operacoes.
     * @param {operacoesUpdateArgs} args - Arguments to update one Operacoes.
     * @example
     * // Update one Operacoes
     * const operacoes = await prisma.operacoes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends operacoesUpdateArgs>(
      args: SelectSubset<T, operacoesUpdateArgs>
    ): Prisma__operacoesClient<operacoesGetPayload<T>>

    /**
     * Delete zero or more Operacoes.
     * @param {operacoesDeleteManyArgs} args - Arguments to filter Operacoes to delete.
     * @example
     * // Delete a few Operacoes
     * const { count } = await prisma.operacoes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends operacoesDeleteManyArgs>(
      args?: SelectSubset<T, operacoesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operacoesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operacoes
     * const operacoes = await prisma.operacoes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends operacoesUpdateManyArgs>(
      args: SelectSubset<T, operacoesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Operacoes.
     * @param {operacoesUpsertArgs} args - Arguments to update or create a Operacoes.
     * @example
     * // Update or create a Operacoes
     * const operacoes = await prisma.operacoes.upsert({
     *   create: {
     *     // ... data to create a Operacoes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operacoes we want to update
     *   }
     * })
    **/
    upsert<T extends operacoesUpsertArgs>(
      args: SelectSubset<T, operacoesUpsertArgs>
    ): Prisma__operacoesClient<operacoesGetPayload<T>>

    /**
     * Count the number of Operacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operacoesCountArgs} args - Arguments to filter Operacoes to count.
     * @example
     * // Count the number of Operacoes
     * const count = await prisma.operacoes.count({
     *   where: {
     *     // ... the filter for the Operacoes we want to count
     *   }
     * })
    **/
    count<T extends operacoesCountArgs>(
      args?: Subset<T, operacoesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperacoesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperacoesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperacoesAggregateArgs>(args: Subset<T, OperacoesAggregateArgs>): Prisma.PrismaPromise<GetOperacoesAggregateType<T>>

    /**
     * Group by Operacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperacoesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperacoesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperacoesGroupByArgs['orderBy'] }
        : { orderBy?: OperacoesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperacoesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperacoesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for operacoes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__operacoesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    relatorios<T extends operacoes$relatoriosArgs= {}>(args?: Subset<T, operacoes$relatoriosArgs>): Prisma.PrismaPromise<Array<relatorio_operacaoGetPayload<T>>| Null>;

    tipos<T extends veiculosArgs= {}>(args?: Subset<T, veiculosArgs>): Prisma__veiculosClient<veiculosGetPayload<T> | Null>;

    motoristas<T extends motoristaArgs= {}>(args?: Subset<T, motoristaArgs>): Prisma__motoristaClient<motoristaGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * operacoes base type for findUnique actions
   */
  export type operacoesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the operacoes
     */
    select?: operacoesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operacoesInclude | null
    /**
     * Filter, which operacoes to fetch.
     */
    where: operacoesWhereUniqueInput
  }

  /**
   * operacoes findUnique
   */
  export interface operacoesFindUniqueArgs extends operacoesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * operacoes findUniqueOrThrow
   */
  export type operacoesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the operacoes
     */
    select?: operacoesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operacoesInclude | null
    /**
     * Filter, which operacoes to fetch.
     */
    where: operacoesWhereUniqueInput
  }


  /**
   * operacoes base type for findFirst actions
   */
  export type operacoesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the operacoes
     */
    select?: operacoesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operacoesInclude | null
    /**
     * Filter, which operacoes to fetch.
     */
    where?: operacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operacoes to fetch.
     */
    orderBy?: Enumerable<operacoesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operacoes.
     */
    cursor?: operacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operacoes.
     */
    distinct?: Enumerable<OperacoesScalarFieldEnum>
  }

  /**
   * operacoes findFirst
   */
  export interface operacoesFindFirstArgs extends operacoesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * operacoes findFirstOrThrow
   */
  export type operacoesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the operacoes
     */
    select?: operacoesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operacoesInclude | null
    /**
     * Filter, which operacoes to fetch.
     */
    where?: operacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operacoes to fetch.
     */
    orderBy?: Enumerable<operacoesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operacoes.
     */
    cursor?: operacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operacoes.
     */
    distinct?: Enumerable<OperacoesScalarFieldEnum>
  }


  /**
   * operacoes findMany
   */
  export type operacoesFindManyArgs = {
    /**
     * Select specific fields to fetch from the operacoes
     */
    select?: operacoesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operacoesInclude | null
    /**
     * Filter, which operacoes to fetch.
     */
    where?: operacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operacoes to fetch.
     */
    orderBy?: Enumerable<operacoesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing operacoes.
     */
    cursor?: operacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operacoes.
     */
    skip?: number
    distinct?: Enumerable<OperacoesScalarFieldEnum>
  }


  /**
   * operacoes create
   */
  export type operacoesCreateArgs = {
    /**
     * Select specific fields to fetch from the operacoes
     */
    select?: operacoesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operacoesInclude | null
    /**
     * The data needed to create a operacoes.
     */
    data: XOR<operacoesCreateInput, operacoesUncheckedCreateInput>
  }


  /**
   * operacoes createMany
   */
  export type operacoesCreateManyArgs = {
    /**
     * The data used to create many operacoes.
     */
    data: Enumerable<operacoesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * operacoes update
   */
  export type operacoesUpdateArgs = {
    /**
     * Select specific fields to fetch from the operacoes
     */
    select?: operacoesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operacoesInclude | null
    /**
     * The data needed to update a operacoes.
     */
    data: XOR<operacoesUpdateInput, operacoesUncheckedUpdateInput>
    /**
     * Choose, which operacoes to update.
     */
    where: operacoesWhereUniqueInput
  }


  /**
   * operacoes updateMany
   */
  export type operacoesUpdateManyArgs = {
    /**
     * The data used to update operacoes.
     */
    data: XOR<operacoesUpdateManyMutationInput, operacoesUncheckedUpdateManyInput>
    /**
     * Filter which operacoes to update
     */
    where?: operacoesWhereInput
  }


  /**
   * operacoes upsert
   */
  export type operacoesUpsertArgs = {
    /**
     * Select specific fields to fetch from the operacoes
     */
    select?: operacoesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operacoesInclude | null
    /**
     * The filter to search for the operacoes to update in case it exists.
     */
    where: operacoesWhereUniqueInput
    /**
     * In case the operacoes found by the `where` argument doesn't exist, create a new operacoes with this data.
     */
    create: XOR<operacoesCreateInput, operacoesUncheckedCreateInput>
    /**
     * In case the operacoes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<operacoesUpdateInput, operacoesUncheckedUpdateInput>
  }


  /**
   * operacoes delete
   */
  export type operacoesDeleteArgs = {
    /**
     * Select specific fields to fetch from the operacoes
     */
    select?: operacoesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operacoesInclude | null
    /**
     * Filter which operacoes to delete.
     */
    where: operacoesWhereUniqueInput
  }


  /**
   * operacoes deleteMany
   */
  export type operacoesDeleteManyArgs = {
    /**
     * Filter which operacoes to delete
     */
    where?: operacoesWhereInput
  }


  /**
   * operacoes.relatorios
   */
  export type operacoes$relatoriosArgs = {
    /**
     * Select specific fields to fetch from the relatorio_operacao
     */
    select?: relatorio_operacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_operacaoInclude | null
    where?: relatorio_operacaoWhereInput
    orderBy?: Enumerable<relatorio_operacaoOrderByWithRelationInput>
    cursor?: relatorio_operacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Relatorio_operacaoScalarFieldEnum>
  }


  /**
   * operacoes without action
   */
  export type operacoesArgs = {
    /**
     * Select specific fields to fetch from the operacoes
     */
    select?: operacoesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: operacoesInclude | null
  }



  /**
   * Model manutencao
   */


  export type AggregateManutencao = {
    _count: ManutencaoCountAggregateOutputType | null
    _avg: ManutencaoAvgAggregateOutputType | null
    _sum: ManutencaoSumAggregateOutputType | null
    _min: ManutencaoMinAggregateOutputType | null
    _max: ManutencaoMaxAggregateOutputType | null
  }

  export type ManutencaoAvgAggregateOutputType = {
    id: number | null
    veiculo: number | null
    valor: number | null
  }

  export type ManutencaoSumAggregateOutputType = {
    id: number | null
    veiculo: number | null
    valor: number | null
  }

  export type ManutencaoMinAggregateOutputType = {
    id: number | null
    veiculo: number | null
    data_inicio: Date | null
    valor: number | null
    descricao: string | null
    data_fim: Date | null
    concluidas: boolean | null
  }

  export type ManutencaoMaxAggregateOutputType = {
    id: number | null
    veiculo: number | null
    data_inicio: Date | null
    valor: number | null
    descricao: string | null
    data_fim: Date | null
    concluidas: boolean | null
  }

  export type ManutencaoCountAggregateOutputType = {
    id: number
    veiculo: number
    data_inicio: number
    valor: number
    descricao: number
    data_fim: number
    concluidas: number
    _all: number
  }


  export type ManutencaoAvgAggregateInputType = {
    id?: true
    veiculo?: true
    valor?: true
  }

  export type ManutencaoSumAggregateInputType = {
    id?: true
    veiculo?: true
    valor?: true
  }

  export type ManutencaoMinAggregateInputType = {
    id?: true
    veiculo?: true
    data_inicio?: true
    valor?: true
    descricao?: true
    data_fim?: true
    concluidas?: true
  }

  export type ManutencaoMaxAggregateInputType = {
    id?: true
    veiculo?: true
    data_inicio?: true
    valor?: true
    descricao?: true
    data_fim?: true
    concluidas?: true
  }

  export type ManutencaoCountAggregateInputType = {
    id?: true
    veiculo?: true
    data_inicio?: true
    valor?: true
    descricao?: true
    data_fim?: true
    concluidas?: true
    _all?: true
  }

  export type ManutencaoAggregateArgs = {
    /**
     * Filter which manutencao to aggregate.
     */
    where?: manutencaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manutencaos to fetch.
     */
    orderBy?: Enumerable<manutencaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: manutencaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manutencaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manutencaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned manutencaos
    **/
    _count?: true | ManutencaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManutencaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManutencaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManutencaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManutencaoMaxAggregateInputType
  }

  export type GetManutencaoAggregateType<T extends ManutencaoAggregateArgs> = {
        [P in keyof T & keyof AggregateManutencao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManutencao[P]>
      : GetScalarType<T[P], AggregateManutencao[P]>
  }




  export type ManutencaoGroupByArgs = {
    where?: manutencaoWhereInput
    orderBy?: Enumerable<manutencaoOrderByWithAggregationInput>
    by: ManutencaoScalarFieldEnum[]
    having?: manutencaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManutencaoCountAggregateInputType | true
    _avg?: ManutencaoAvgAggregateInputType
    _sum?: ManutencaoSumAggregateInputType
    _min?: ManutencaoMinAggregateInputType
    _max?: ManutencaoMaxAggregateInputType
  }


  export type ManutencaoGroupByOutputType = {
    id: number
    veiculo: number
    data_inicio: Date
    valor: number
    descricao: string
    data_fim: Date | null
    concluidas: boolean
    _count: ManutencaoCountAggregateOutputType | null
    _avg: ManutencaoAvgAggregateOutputType | null
    _sum: ManutencaoSumAggregateOutputType | null
    _min: ManutencaoMinAggregateOutputType | null
    _max: ManutencaoMaxAggregateOutputType | null
  }

  type GetManutencaoGroupByPayload<T extends ManutencaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ManutencaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManutencaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManutencaoGroupByOutputType[P]>
            : GetScalarType<T[P], ManutencaoGroupByOutputType[P]>
        }
      >
    >


  export type manutencaoSelect = {
    id?: boolean
    veiculo?: boolean
    data_inicio?: boolean
    valor?: boolean
    descricao?: boolean
    data_fim?: boolean
    concluidas?: boolean
    manutencao?: boolean | manutencao$manutencaoArgs
    veiculos?: boolean | veiculosArgs
    _count?: boolean | ManutencaoCountOutputTypeArgs
  }


  export type manutencaoInclude = {
    manutencao?: boolean | manutencao$manutencaoArgs
    veiculos?: boolean | veiculosArgs
    _count?: boolean | ManutencaoCountOutputTypeArgs
  }

  export type manutencaoGetPayload<S extends boolean | null | undefined | manutencaoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? manutencao :
    S extends undefined ? never :
    S extends { include: any } & (manutencaoArgs | manutencaoFindManyArgs)
    ? manutencao  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'manutencao' ? Array < relatorio_manutencaoGetPayload<S['include'][P]>>  :
        P extends 'veiculos' ? veiculosGetPayload<S['include'][P]> :
        P extends '_count' ? ManutencaoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (manutencaoArgs | manutencaoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'manutencao' ? Array < relatorio_manutencaoGetPayload<S['select'][P]>>  :
        P extends 'veiculos' ? veiculosGetPayload<S['select'][P]> :
        P extends '_count' ? ManutencaoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof manutencao ? manutencao[P] : never
  } 
      : manutencao


  type manutencaoCountArgs = 
    Omit<manutencaoFindManyArgs, 'select' | 'include'> & {
      select?: ManutencaoCountAggregateInputType | true
    }

  export interface manutencaoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Manutencao that matches the filter.
     * @param {manutencaoFindUniqueArgs} args - Arguments to find a Manutencao
     * @example
     * // Get one Manutencao
     * const manutencao = await prisma.manutencao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends manutencaoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, manutencaoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'manutencao'> extends True ? Prisma__manutencaoClient<manutencaoGetPayload<T>> : Prisma__manutencaoClient<manutencaoGetPayload<T> | null, null>

    /**
     * Find one Manutencao that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {manutencaoFindUniqueOrThrowArgs} args - Arguments to find a Manutencao
     * @example
     * // Get one Manutencao
     * const manutencao = await prisma.manutencao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends manutencaoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, manutencaoFindUniqueOrThrowArgs>
    ): Prisma__manutencaoClient<manutencaoGetPayload<T>>

    /**
     * Find the first Manutencao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manutencaoFindFirstArgs} args - Arguments to find a Manutencao
     * @example
     * // Get one Manutencao
     * const manutencao = await prisma.manutencao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends manutencaoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, manutencaoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'manutencao'> extends True ? Prisma__manutencaoClient<manutencaoGetPayload<T>> : Prisma__manutencaoClient<manutencaoGetPayload<T> | null, null>

    /**
     * Find the first Manutencao that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manutencaoFindFirstOrThrowArgs} args - Arguments to find a Manutencao
     * @example
     * // Get one Manutencao
     * const manutencao = await prisma.manutencao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends manutencaoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, manutencaoFindFirstOrThrowArgs>
    ): Prisma__manutencaoClient<manutencaoGetPayload<T>>

    /**
     * Find zero or more Manutencaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manutencaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Manutencaos
     * const manutencaos = await prisma.manutencao.findMany()
     * 
     * // Get first 10 Manutencaos
     * const manutencaos = await prisma.manutencao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manutencaoWithIdOnly = await prisma.manutencao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends manutencaoFindManyArgs>(
      args?: SelectSubset<T, manutencaoFindManyArgs>
    ): Prisma.PrismaPromise<Array<manutencaoGetPayload<T>>>

    /**
     * Create a Manutencao.
     * @param {manutencaoCreateArgs} args - Arguments to create a Manutencao.
     * @example
     * // Create one Manutencao
     * const Manutencao = await prisma.manutencao.create({
     *   data: {
     *     // ... data to create a Manutencao
     *   }
     * })
     * 
    **/
    create<T extends manutencaoCreateArgs>(
      args: SelectSubset<T, manutencaoCreateArgs>
    ): Prisma__manutencaoClient<manutencaoGetPayload<T>>

    /**
     * Create many Manutencaos.
     *     @param {manutencaoCreateManyArgs} args - Arguments to create many Manutencaos.
     *     @example
     *     // Create many Manutencaos
     *     const manutencao = await prisma.manutencao.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends manutencaoCreateManyArgs>(
      args?: SelectSubset<T, manutencaoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Manutencao.
     * @param {manutencaoDeleteArgs} args - Arguments to delete one Manutencao.
     * @example
     * // Delete one Manutencao
     * const Manutencao = await prisma.manutencao.delete({
     *   where: {
     *     // ... filter to delete one Manutencao
     *   }
     * })
     * 
    **/
    delete<T extends manutencaoDeleteArgs>(
      args: SelectSubset<T, manutencaoDeleteArgs>
    ): Prisma__manutencaoClient<manutencaoGetPayload<T>>

    /**
     * Update one Manutencao.
     * @param {manutencaoUpdateArgs} args - Arguments to update one Manutencao.
     * @example
     * // Update one Manutencao
     * const manutencao = await prisma.manutencao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends manutencaoUpdateArgs>(
      args: SelectSubset<T, manutencaoUpdateArgs>
    ): Prisma__manutencaoClient<manutencaoGetPayload<T>>

    /**
     * Delete zero or more Manutencaos.
     * @param {manutencaoDeleteManyArgs} args - Arguments to filter Manutencaos to delete.
     * @example
     * // Delete a few Manutencaos
     * const { count } = await prisma.manutencao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends manutencaoDeleteManyArgs>(
      args?: SelectSubset<T, manutencaoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manutencaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manutencaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Manutencaos
     * const manutencao = await prisma.manutencao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends manutencaoUpdateManyArgs>(
      args: SelectSubset<T, manutencaoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manutencao.
     * @param {manutencaoUpsertArgs} args - Arguments to update or create a Manutencao.
     * @example
     * // Update or create a Manutencao
     * const manutencao = await prisma.manutencao.upsert({
     *   create: {
     *     // ... data to create a Manutencao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manutencao we want to update
     *   }
     * })
    **/
    upsert<T extends manutencaoUpsertArgs>(
      args: SelectSubset<T, manutencaoUpsertArgs>
    ): Prisma__manutencaoClient<manutencaoGetPayload<T>>

    /**
     * Count the number of Manutencaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manutencaoCountArgs} args - Arguments to filter Manutencaos to count.
     * @example
     * // Count the number of Manutencaos
     * const count = await prisma.manutencao.count({
     *   where: {
     *     // ... the filter for the Manutencaos we want to count
     *   }
     * })
    **/
    count<T extends manutencaoCountArgs>(
      args?: Subset<T, manutencaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManutencaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manutencao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManutencaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManutencaoAggregateArgs>(args: Subset<T, ManutencaoAggregateArgs>): Prisma.PrismaPromise<GetManutencaoAggregateType<T>>

    /**
     * Group by Manutencao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManutencaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManutencaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManutencaoGroupByArgs['orderBy'] }
        : { orderBy?: ManutencaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManutencaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManutencaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for manutencao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__manutencaoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    manutencao<T extends manutencao$manutencaoArgs= {}>(args?: Subset<T, manutencao$manutencaoArgs>): Prisma.PrismaPromise<Array<relatorio_manutencaoGetPayload<T>>| Null>;

    veiculos<T extends veiculosArgs= {}>(args?: Subset<T, veiculosArgs>): Prisma__veiculosClient<veiculosGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * manutencao base type for findUnique actions
   */
  export type manutencaoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the manutencao
     */
    select?: manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manutencaoInclude | null
    /**
     * Filter, which manutencao to fetch.
     */
    where: manutencaoWhereUniqueInput
  }

  /**
   * manutencao findUnique
   */
  export interface manutencaoFindUniqueArgs extends manutencaoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * manutencao findUniqueOrThrow
   */
  export type manutencaoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the manutencao
     */
    select?: manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manutencaoInclude | null
    /**
     * Filter, which manutencao to fetch.
     */
    where: manutencaoWhereUniqueInput
  }


  /**
   * manutencao base type for findFirst actions
   */
  export type manutencaoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the manutencao
     */
    select?: manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manutencaoInclude | null
    /**
     * Filter, which manutencao to fetch.
     */
    where?: manutencaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manutencaos to fetch.
     */
    orderBy?: Enumerable<manutencaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manutencaos.
     */
    cursor?: manutencaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manutencaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manutencaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manutencaos.
     */
    distinct?: Enumerable<ManutencaoScalarFieldEnum>
  }

  /**
   * manutencao findFirst
   */
  export interface manutencaoFindFirstArgs extends manutencaoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * manutencao findFirstOrThrow
   */
  export type manutencaoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the manutencao
     */
    select?: manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manutencaoInclude | null
    /**
     * Filter, which manutencao to fetch.
     */
    where?: manutencaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manutencaos to fetch.
     */
    orderBy?: Enumerable<manutencaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manutencaos.
     */
    cursor?: manutencaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manutencaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manutencaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manutencaos.
     */
    distinct?: Enumerable<ManutencaoScalarFieldEnum>
  }


  /**
   * manutencao findMany
   */
  export type manutencaoFindManyArgs = {
    /**
     * Select specific fields to fetch from the manutencao
     */
    select?: manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manutencaoInclude | null
    /**
     * Filter, which manutencaos to fetch.
     */
    where?: manutencaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manutencaos to fetch.
     */
    orderBy?: Enumerable<manutencaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing manutencaos.
     */
    cursor?: manutencaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manutencaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manutencaos.
     */
    skip?: number
    distinct?: Enumerable<ManutencaoScalarFieldEnum>
  }


  /**
   * manutencao create
   */
  export type manutencaoCreateArgs = {
    /**
     * Select specific fields to fetch from the manutencao
     */
    select?: manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manutencaoInclude | null
    /**
     * The data needed to create a manutencao.
     */
    data: XOR<manutencaoCreateInput, manutencaoUncheckedCreateInput>
  }


  /**
   * manutencao createMany
   */
  export type manutencaoCreateManyArgs = {
    /**
     * The data used to create many manutencaos.
     */
    data: Enumerable<manutencaoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * manutencao update
   */
  export type manutencaoUpdateArgs = {
    /**
     * Select specific fields to fetch from the manutencao
     */
    select?: manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manutencaoInclude | null
    /**
     * The data needed to update a manutencao.
     */
    data: XOR<manutencaoUpdateInput, manutencaoUncheckedUpdateInput>
    /**
     * Choose, which manutencao to update.
     */
    where: manutencaoWhereUniqueInput
  }


  /**
   * manutencao updateMany
   */
  export type manutencaoUpdateManyArgs = {
    /**
     * The data used to update manutencaos.
     */
    data: XOR<manutencaoUpdateManyMutationInput, manutencaoUncheckedUpdateManyInput>
    /**
     * Filter which manutencaos to update
     */
    where?: manutencaoWhereInput
  }


  /**
   * manutencao upsert
   */
  export type manutencaoUpsertArgs = {
    /**
     * Select specific fields to fetch from the manutencao
     */
    select?: manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manutencaoInclude | null
    /**
     * The filter to search for the manutencao to update in case it exists.
     */
    where: manutencaoWhereUniqueInput
    /**
     * In case the manutencao found by the `where` argument doesn't exist, create a new manutencao with this data.
     */
    create: XOR<manutencaoCreateInput, manutencaoUncheckedCreateInput>
    /**
     * In case the manutencao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<manutencaoUpdateInput, manutencaoUncheckedUpdateInput>
  }


  /**
   * manutencao delete
   */
  export type manutencaoDeleteArgs = {
    /**
     * Select specific fields to fetch from the manutencao
     */
    select?: manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manutencaoInclude | null
    /**
     * Filter which manutencao to delete.
     */
    where: manutencaoWhereUniqueInput
  }


  /**
   * manutencao deleteMany
   */
  export type manutencaoDeleteManyArgs = {
    /**
     * Filter which manutencaos to delete
     */
    where?: manutencaoWhereInput
  }


  /**
   * manutencao.manutencao
   */
  export type manutencao$manutencaoArgs = {
    /**
     * Select specific fields to fetch from the relatorio_manutencao
     */
    select?: relatorio_manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_manutencaoInclude | null
    where?: relatorio_manutencaoWhereInput
    orderBy?: Enumerable<relatorio_manutencaoOrderByWithRelationInput>
    cursor?: relatorio_manutencaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Relatorio_manutencaoScalarFieldEnum>
  }


  /**
   * manutencao without action
   */
  export type manutencaoArgs = {
    /**
     * Select specific fields to fetch from the manutencao
     */
    select?: manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: manutencaoInclude | null
  }



  /**
   * Model relatorio_manutencao
   */


  export type AggregateRelatorio_manutencao = {
    _count: Relatorio_manutencaoCountAggregateOutputType | null
    _avg: Relatorio_manutencaoAvgAggregateOutputType | null
    _sum: Relatorio_manutencaoSumAggregateOutputType | null
    _min: Relatorio_manutencaoMinAggregateOutputType | null
    _max: Relatorio_manutencaoMaxAggregateOutputType | null
  }

  export type Relatorio_manutencaoAvgAggregateOutputType = {
    id: number | null
    manutencao: number | null
  }

  export type Relatorio_manutencaoSumAggregateOutputType = {
    id: number | null
    manutencao: number | null
  }

  export type Relatorio_manutencaoMinAggregateOutputType = {
    id: number | null
    manutencao: number | null
  }

  export type Relatorio_manutencaoMaxAggregateOutputType = {
    id: number | null
    manutencao: number | null
  }

  export type Relatorio_manutencaoCountAggregateOutputType = {
    id: number
    manutencao: number
    _all: number
  }


  export type Relatorio_manutencaoAvgAggregateInputType = {
    id?: true
    manutencao?: true
  }

  export type Relatorio_manutencaoSumAggregateInputType = {
    id?: true
    manutencao?: true
  }

  export type Relatorio_manutencaoMinAggregateInputType = {
    id?: true
    manutencao?: true
  }

  export type Relatorio_manutencaoMaxAggregateInputType = {
    id?: true
    manutencao?: true
  }

  export type Relatorio_manutencaoCountAggregateInputType = {
    id?: true
    manutencao?: true
    _all?: true
  }

  export type Relatorio_manutencaoAggregateArgs = {
    /**
     * Filter which relatorio_manutencao to aggregate.
     */
    where?: relatorio_manutencaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relatorio_manutencaos to fetch.
     */
    orderBy?: Enumerable<relatorio_manutencaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: relatorio_manutencaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relatorio_manutencaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relatorio_manutencaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned relatorio_manutencaos
    **/
    _count?: true | Relatorio_manutencaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Relatorio_manutencaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Relatorio_manutencaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Relatorio_manutencaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Relatorio_manutencaoMaxAggregateInputType
  }

  export type GetRelatorio_manutencaoAggregateType<T extends Relatorio_manutencaoAggregateArgs> = {
        [P in keyof T & keyof AggregateRelatorio_manutencao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelatorio_manutencao[P]>
      : GetScalarType<T[P], AggregateRelatorio_manutencao[P]>
  }




  export type Relatorio_manutencaoGroupByArgs = {
    where?: relatorio_manutencaoWhereInput
    orderBy?: Enumerable<relatorio_manutencaoOrderByWithAggregationInput>
    by: Relatorio_manutencaoScalarFieldEnum[]
    having?: relatorio_manutencaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Relatorio_manutencaoCountAggregateInputType | true
    _avg?: Relatorio_manutencaoAvgAggregateInputType
    _sum?: Relatorio_manutencaoSumAggregateInputType
    _min?: Relatorio_manutencaoMinAggregateInputType
    _max?: Relatorio_manutencaoMaxAggregateInputType
  }


  export type Relatorio_manutencaoGroupByOutputType = {
    id: number
    manutencao: number
    _count: Relatorio_manutencaoCountAggregateOutputType | null
    _avg: Relatorio_manutencaoAvgAggregateOutputType | null
    _sum: Relatorio_manutencaoSumAggregateOutputType | null
    _min: Relatorio_manutencaoMinAggregateOutputType | null
    _max: Relatorio_manutencaoMaxAggregateOutputType | null
  }

  type GetRelatorio_manutencaoGroupByPayload<T extends Relatorio_manutencaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Relatorio_manutencaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Relatorio_manutencaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Relatorio_manutencaoGroupByOutputType[P]>
            : GetScalarType<T[P], Relatorio_manutencaoGroupByOutputType[P]>
        }
      >
    >


  export type relatorio_manutencaoSelect = {
    id?: boolean
    manutencao?: boolean
    manutencoes?: boolean | manutencaoArgs
  }


  export type relatorio_manutencaoInclude = {
    manutencoes?: boolean | manutencaoArgs
  }

  export type relatorio_manutencaoGetPayload<S extends boolean | null | undefined | relatorio_manutencaoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? relatorio_manutencao :
    S extends undefined ? never :
    S extends { include: any } & (relatorio_manutencaoArgs | relatorio_manutencaoFindManyArgs)
    ? relatorio_manutencao  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'manutencoes' ? manutencaoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (relatorio_manutencaoArgs | relatorio_manutencaoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'manutencoes' ? manutencaoGetPayload<S['select'][P]> :  P extends keyof relatorio_manutencao ? relatorio_manutencao[P] : never
  } 
      : relatorio_manutencao


  type relatorio_manutencaoCountArgs = 
    Omit<relatorio_manutencaoFindManyArgs, 'select' | 'include'> & {
      select?: Relatorio_manutencaoCountAggregateInputType | true
    }

  export interface relatorio_manutencaoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Relatorio_manutencao that matches the filter.
     * @param {relatorio_manutencaoFindUniqueArgs} args - Arguments to find a Relatorio_manutencao
     * @example
     * // Get one Relatorio_manutencao
     * const relatorio_manutencao = await prisma.relatorio_manutencao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends relatorio_manutencaoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, relatorio_manutencaoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'relatorio_manutencao'> extends True ? Prisma__relatorio_manutencaoClient<relatorio_manutencaoGetPayload<T>> : Prisma__relatorio_manutencaoClient<relatorio_manutencaoGetPayload<T> | null, null>

    /**
     * Find one Relatorio_manutencao that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {relatorio_manutencaoFindUniqueOrThrowArgs} args - Arguments to find a Relatorio_manutencao
     * @example
     * // Get one Relatorio_manutencao
     * const relatorio_manutencao = await prisma.relatorio_manutencao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends relatorio_manutencaoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, relatorio_manutencaoFindUniqueOrThrowArgs>
    ): Prisma__relatorio_manutencaoClient<relatorio_manutencaoGetPayload<T>>

    /**
     * Find the first Relatorio_manutencao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relatorio_manutencaoFindFirstArgs} args - Arguments to find a Relatorio_manutencao
     * @example
     * // Get one Relatorio_manutencao
     * const relatorio_manutencao = await prisma.relatorio_manutencao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends relatorio_manutencaoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, relatorio_manutencaoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'relatorio_manutencao'> extends True ? Prisma__relatorio_manutencaoClient<relatorio_manutencaoGetPayload<T>> : Prisma__relatorio_manutencaoClient<relatorio_manutencaoGetPayload<T> | null, null>

    /**
     * Find the first Relatorio_manutencao that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relatorio_manutencaoFindFirstOrThrowArgs} args - Arguments to find a Relatorio_manutencao
     * @example
     * // Get one Relatorio_manutencao
     * const relatorio_manutencao = await prisma.relatorio_manutencao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends relatorio_manutencaoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, relatorio_manutencaoFindFirstOrThrowArgs>
    ): Prisma__relatorio_manutencaoClient<relatorio_manutencaoGetPayload<T>>

    /**
     * Find zero or more Relatorio_manutencaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relatorio_manutencaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Relatorio_manutencaos
     * const relatorio_manutencaos = await prisma.relatorio_manutencao.findMany()
     * 
     * // Get first 10 Relatorio_manutencaos
     * const relatorio_manutencaos = await prisma.relatorio_manutencao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relatorio_manutencaoWithIdOnly = await prisma.relatorio_manutencao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends relatorio_manutencaoFindManyArgs>(
      args?: SelectSubset<T, relatorio_manutencaoFindManyArgs>
    ): Prisma.PrismaPromise<Array<relatorio_manutencaoGetPayload<T>>>

    /**
     * Create a Relatorio_manutencao.
     * @param {relatorio_manutencaoCreateArgs} args - Arguments to create a Relatorio_manutencao.
     * @example
     * // Create one Relatorio_manutencao
     * const Relatorio_manutencao = await prisma.relatorio_manutencao.create({
     *   data: {
     *     // ... data to create a Relatorio_manutencao
     *   }
     * })
     * 
    **/
    create<T extends relatorio_manutencaoCreateArgs>(
      args: SelectSubset<T, relatorio_manutencaoCreateArgs>
    ): Prisma__relatorio_manutencaoClient<relatorio_manutencaoGetPayload<T>>

    /**
     * Create many Relatorio_manutencaos.
     *     @param {relatorio_manutencaoCreateManyArgs} args - Arguments to create many Relatorio_manutencaos.
     *     @example
     *     // Create many Relatorio_manutencaos
     *     const relatorio_manutencao = await prisma.relatorio_manutencao.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends relatorio_manutencaoCreateManyArgs>(
      args?: SelectSubset<T, relatorio_manutencaoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Relatorio_manutencao.
     * @param {relatorio_manutencaoDeleteArgs} args - Arguments to delete one Relatorio_manutencao.
     * @example
     * // Delete one Relatorio_manutencao
     * const Relatorio_manutencao = await prisma.relatorio_manutencao.delete({
     *   where: {
     *     // ... filter to delete one Relatorio_manutencao
     *   }
     * })
     * 
    **/
    delete<T extends relatorio_manutencaoDeleteArgs>(
      args: SelectSubset<T, relatorio_manutencaoDeleteArgs>
    ): Prisma__relatorio_manutencaoClient<relatorio_manutencaoGetPayload<T>>

    /**
     * Update one Relatorio_manutencao.
     * @param {relatorio_manutencaoUpdateArgs} args - Arguments to update one Relatorio_manutencao.
     * @example
     * // Update one Relatorio_manutencao
     * const relatorio_manutencao = await prisma.relatorio_manutencao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends relatorio_manutencaoUpdateArgs>(
      args: SelectSubset<T, relatorio_manutencaoUpdateArgs>
    ): Prisma__relatorio_manutencaoClient<relatorio_manutencaoGetPayload<T>>

    /**
     * Delete zero or more Relatorio_manutencaos.
     * @param {relatorio_manutencaoDeleteManyArgs} args - Arguments to filter Relatorio_manutencaos to delete.
     * @example
     * // Delete a few Relatorio_manutencaos
     * const { count } = await prisma.relatorio_manutencao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends relatorio_manutencaoDeleteManyArgs>(
      args?: SelectSubset<T, relatorio_manutencaoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Relatorio_manutencaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relatorio_manutencaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Relatorio_manutencaos
     * const relatorio_manutencao = await prisma.relatorio_manutencao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends relatorio_manutencaoUpdateManyArgs>(
      args: SelectSubset<T, relatorio_manutencaoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Relatorio_manutencao.
     * @param {relatorio_manutencaoUpsertArgs} args - Arguments to update or create a Relatorio_manutencao.
     * @example
     * // Update or create a Relatorio_manutencao
     * const relatorio_manutencao = await prisma.relatorio_manutencao.upsert({
     *   create: {
     *     // ... data to create a Relatorio_manutencao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Relatorio_manutencao we want to update
     *   }
     * })
    **/
    upsert<T extends relatorio_manutencaoUpsertArgs>(
      args: SelectSubset<T, relatorio_manutencaoUpsertArgs>
    ): Prisma__relatorio_manutencaoClient<relatorio_manutencaoGetPayload<T>>

    /**
     * Count the number of Relatorio_manutencaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relatorio_manutencaoCountArgs} args - Arguments to filter Relatorio_manutencaos to count.
     * @example
     * // Count the number of Relatorio_manutencaos
     * const count = await prisma.relatorio_manutencao.count({
     *   where: {
     *     // ... the filter for the Relatorio_manutencaos we want to count
     *   }
     * })
    **/
    count<T extends relatorio_manutencaoCountArgs>(
      args?: Subset<T, relatorio_manutencaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Relatorio_manutencaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Relatorio_manutencao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Relatorio_manutencaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Relatorio_manutencaoAggregateArgs>(args: Subset<T, Relatorio_manutencaoAggregateArgs>): Prisma.PrismaPromise<GetRelatorio_manutencaoAggregateType<T>>

    /**
     * Group by Relatorio_manutencao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Relatorio_manutencaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Relatorio_manutencaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Relatorio_manutencaoGroupByArgs['orderBy'] }
        : { orderBy?: Relatorio_manutencaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Relatorio_manutencaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelatorio_manutencaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for relatorio_manutencao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__relatorio_manutencaoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    manutencoes<T extends manutencaoArgs= {}>(args?: Subset<T, manutencaoArgs>): Prisma__manutencaoClient<manutencaoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * relatorio_manutencao base type for findUnique actions
   */
  export type relatorio_manutencaoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the relatorio_manutencao
     */
    select?: relatorio_manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_manutencaoInclude | null
    /**
     * Filter, which relatorio_manutencao to fetch.
     */
    where: relatorio_manutencaoWhereUniqueInput
  }

  /**
   * relatorio_manutencao findUnique
   */
  export interface relatorio_manutencaoFindUniqueArgs extends relatorio_manutencaoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * relatorio_manutencao findUniqueOrThrow
   */
  export type relatorio_manutencaoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the relatorio_manutencao
     */
    select?: relatorio_manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_manutencaoInclude | null
    /**
     * Filter, which relatorio_manutencao to fetch.
     */
    where: relatorio_manutencaoWhereUniqueInput
  }


  /**
   * relatorio_manutencao base type for findFirst actions
   */
  export type relatorio_manutencaoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the relatorio_manutencao
     */
    select?: relatorio_manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_manutencaoInclude | null
    /**
     * Filter, which relatorio_manutencao to fetch.
     */
    where?: relatorio_manutencaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relatorio_manutencaos to fetch.
     */
    orderBy?: Enumerable<relatorio_manutencaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for relatorio_manutencaos.
     */
    cursor?: relatorio_manutencaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relatorio_manutencaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relatorio_manutencaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of relatorio_manutencaos.
     */
    distinct?: Enumerable<Relatorio_manutencaoScalarFieldEnum>
  }

  /**
   * relatorio_manutencao findFirst
   */
  export interface relatorio_manutencaoFindFirstArgs extends relatorio_manutencaoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * relatorio_manutencao findFirstOrThrow
   */
  export type relatorio_manutencaoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the relatorio_manutencao
     */
    select?: relatorio_manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_manutencaoInclude | null
    /**
     * Filter, which relatorio_manutencao to fetch.
     */
    where?: relatorio_manutencaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relatorio_manutencaos to fetch.
     */
    orderBy?: Enumerable<relatorio_manutencaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for relatorio_manutencaos.
     */
    cursor?: relatorio_manutencaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relatorio_manutencaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relatorio_manutencaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of relatorio_manutencaos.
     */
    distinct?: Enumerable<Relatorio_manutencaoScalarFieldEnum>
  }


  /**
   * relatorio_manutencao findMany
   */
  export type relatorio_manutencaoFindManyArgs = {
    /**
     * Select specific fields to fetch from the relatorio_manutencao
     */
    select?: relatorio_manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_manutencaoInclude | null
    /**
     * Filter, which relatorio_manutencaos to fetch.
     */
    where?: relatorio_manutencaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relatorio_manutencaos to fetch.
     */
    orderBy?: Enumerable<relatorio_manutencaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing relatorio_manutencaos.
     */
    cursor?: relatorio_manutencaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relatorio_manutencaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relatorio_manutencaos.
     */
    skip?: number
    distinct?: Enumerable<Relatorio_manutencaoScalarFieldEnum>
  }


  /**
   * relatorio_manutencao create
   */
  export type relatorio_manutencaoCreateArgs = {
    /**
     * Select specific fields to fetch from the relatorio_manutencao
     */
    select?: relatorio_manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_manutencaoInclude | null
    /**
     * The data needed to create a relatorio_manutencao.
     */
    data: XOR<relatorio_manutencaoCreateInput, relatorio_manutencaoUncheckedCreateInput>
  }


  /**
   * relatorio_manutencao createMany
   */
  export type relatorio_manutencaoCreateManyArgs = {
    /**
     * The data used to create many relatorio_manutencaos.
     */
    data: Enumerable<relatorio_manutencaoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * relatorio_manutencao update
   */
  export type relatorio_manutencaoUpdateArgs = {
    /**
     * Select specific fields to fetch from the relatorio_manutencao
     */
    select?: relatorio_manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_manutencaoInclude | null
    /**
     * The data needed to update a relatorio_manutencao.
     */
    data: XOR<relatorio_manutencaoUpdateInput, relatorio_manutencaoUncheckedUpdateInput>
    /**
     * Choose, which relatorio_manutencao to update.
     */
    where: relatorio_manutencaoWhereUniqueInput
  }


  /**
   * relatorio_manutencao updateMany
   */
  export type relatorio_manutencaoUpdateManyArgs = {
    /**
     * The data used to update relatorio_manutencaos.
     */
    data: XOR<relatorio_manutencaoUpdateManyMutationInput, relatorio_manutencaoUncheckedUpdateManyInput>
    /**
     * Filter which relatorio_manutencaos to update
     */
    where?: relatorio_manutencaoWhereInput
  }


  /**
   * relatorio_manutencao upsert
   */
  export type relatorio_manutencaoUpsertArgs = {
    /**
     * Select specific fields to fetch from the relatorio_manutencao
     */
    select?: relatorio_manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_manutencaoInclude | null
    /**
     * The filter to search for the relatorio_manutencao to update in case it exists.
     */
    where: relatorio_manutencaoWhereUniqueInput
    /**
     * In case the relatorio_manutencao found by the `where` argument doesn't exist, create a new relatorio_manutencao with this data.
     */
    create: XOR<relatorio_manutencaoCreateInput, relatorio_manutencaoUncheckedCreateInput>
    /**
     * In case the relatorio_manutencao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<relatorio_manutencaoUpdateInput, relatorio_manutencaoUncheckedUpdateInput>
  }


  /**
   * relatorio_manutencao delete
   */
  export type relatorio_manutencaoDeleteArgs = {
    /**
     * Select specific fields to fetch from the relatorio_manutencao
     */
    select?: relatorio_manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_manutencaoInclude | null
    /**
     * Filter which relatorio_manutencao to delete.
     */
    where: relatorio_manutencaoWhereUniqueInput
  }


  /**
   * relatorio_manutencao deleteMany
   */
  export type relatorio_manutencaoDeleteManyArgs = {
    /**
     * Filter which relatorio_manutencaos to delete
     */
    where?: relatorio_manutencaoWhereInput
  }


  /**
   * relatorio_manutencao without action
   */
  export type relatorio_manutencaoArgs = {
    /**
     * Select specific fields to fetch from the relatorio_manutencao
     */
    select?: relatorio_manutencaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_manutencaoInclude | null
  }



  /**
   * Model relatorio_operacao
   */


  export type AggregateRelatorio_operacao = {
    _count: Relatorio_operacaoCountAggregateOutputType | null
    _avg: Relatorio_operacaoAvgAggregateOutputType | null
    _sum: Relatorio_operacaoSumAggregateOutputType | null
    _min: Relatorio_operacaoMinAggregateOutputType | null
    _max: Relatorio_operacaoMaxAggregateOutputType | null
  }

  export type Relatorio_operacaoAvgAggregateOutputType = {
    id: number | null
    operacoes: number | null
  }

  export type Relatorio_operacaoSumAggregateOutputType = {
    id: number | null
    operacoes: number | null
  }

  export type Relatorio_operacaoMinAggregateOutputType = {
    id: number | null
    operacoes: number | null
  }

  export type Relatorio_operacaoMaxAggregateOutputType = {
    id: number | null
    operacoes: number | null
  }

  export type Relatorio_operacaoCountAggregateOutputType = {
    id: number
    operacoes: number
    _all: number
  }


  export type Relatorio_operacaoAvgAggregateInputType = {
    id?: true
    operacoes?: true
  }

  export type Relatorio_operacaoSumAggregateInputType = {
    id?: true
    operacoes?: true
  }

  export type Relatorio_operacaoMinAggregateInputType = {
    id?: true
    operacoes?: true
  }

  export type Relatorio_operacaoMaxAggregateInputType = {
    id?: true
    operacoes?: true
  }

  export type Relatorio_operacaoCountAggregateInputType = {
    id?: true
    operacoes?: true
    _all?: true
  }

  export type Relatorio_operacaoAggregateArgs = {
    /**
     * Filter which relatorio_operacao to aggregate.
     */
    where?: relatorio_operacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relatorio_operacaos to fetch.
     */
    orderBy?: Enumerable<relatorio_operacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: relatorio_operacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relatorio_operacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relatorio_operacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned relatorio_operacaos
    **/
    _count?: true | Relatorio_operacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Relatorio_operacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Relatorio_operacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Relatorio_operacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Relatorio_operacaoMaxAggregateInputType
  }

  export type GetRelatorio_operacaoAggregateType<T extends Relatorio_operacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateRelatorio_operacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelatorio_operacao[P]>
      : GetScalarType<T[P], AggregateRelatorio_operacao[P]>
  }




  export type Relatorio_operacaoGroupByArgs = {
    where?: relatorio_operacaoWhereInput
    orderBy?: Enumerable<relatorio_operacaoOrderByWithAggregationInput>
    by: Relatorio_operacaoScalarFieldEnum[]
    having?: relatorio_operacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Relatorio_operacaoCountAggregateInputType | true
    _avg?: Relatorio_operacaoAvgAggregateInputType
    _sum?: Relatorio_operacaoSumAggregateInputType
    _min?: Relatorio_operacaoMinAggregateInputType
    _max?: Relatorio_operacaoMaxAggregateInputType
  }


  export type Relatorio_operacaoGroupByOutputType = {
    id: number
    operacoes: number
    _count: Relatorio_operacaoCountAggregateOutputType | null
    _avg: Relatorio_operacaoAvgAggregateOutputType | null
    _sum: Relatorio_operacaoSumAggregateOutputType | null
    _min: Relatorio_operacaoMinAggregateOutputType | null
    _max: Relatorio_operacaoMaxAggregateOutputType | null
  }

  type GetRelatorio_operacaoGroupByPayload<T extends Relatorio_operacaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Relatorio_operacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Relatorio_operacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Relatorio_operacaoGroupByOutputType[P]>
            : GetScalarType<T[P], Relatorio_operacaoGroupByOutputType[P]>
        }
      >
    >


  export type relatorio_operacaoSelect = {
    id?: boolean
    operacoes?: boolean
    operacao?: boolean | operacoesArgs
  }


  export type relatorio_operacaoInclude = {
    operacao?: boolean | operacoesArgs
  }

  export type relatorio_operacaoGetPayload<S extends boolean | null | undefined | relatorio_operacaoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? relatorio_operacao :
    S extends undefined ? never :
    S extends { include: any } & (relatorio_operacaoArgs | relatorio_operacaoFindManyArgs)
    ? relatorio_operacao  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'operacao' ? operacoesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (relatorio_operacaoArgs | relatorio_operacaoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'operacao' ? operacoesGetPayload<S['select'][P]> :  P extends keyof relatorio_operacao ? relatorio_operacao[P] : never
  } 
      : relatorio_operacao


  type relatorio_operacaoCountArgs = 
    Omit<relatorio_operacaoFindManyArgs, 'select' | 'include'> & {
      select?: Relatorio_operacaoCountAggregateInputType | true
    }

  export interface relatorio_operacaoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Relatorio_operacao that matches the filter.
     * @param {relatorio_operacaoFindUniqueArgs} args - Arguments to find a Relatorio_operacao
     * @example
     * // Get one Relatorio_operacao
     * const relatorio_operacao = await prisma.relatorio_operacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends relatorio_operacaoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, relatorio_operacaoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'relatorio_operacao'> extends True ? Prisma__relatorio_operacaoClient<relatorio_operacaoGetPayload<T>> : Prisma__relatorio_operacaoClient<relatorio_operacaoGetPayload<T> | null, null>

    /**
     * Find one Relatorio_operacao that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {relatorio_operacaoFindUniqueOrThrowArgs} args - Arguments to find a Relatorio_operacao
     * @example
     * // Get one Relatorio_operacao
     * const relatorio_operacao = await prisma.relatorio_operacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends relatorio_operacaoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, relatorio_operacaoFindUniqueOrThrowArgs>
    ): Prisma__relatorio_operacaoClient<relatorio_operacaoGetPayload<T>>

    /**
     * Find the first Relatorio_operacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relatorio_operacaoFindFirstArgs} args - Arguments to find a Relatorio_operacao
     * @example
     * // Get one Relatorio_operacao
     * const relatorio_operacao = await prisma.relatorio_operacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends relatorio_operacaoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, relatorio_operacaoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'relatorio_operacao'> extends True ? Prisma__relatorio_operacaoClient<relatorio_operacaoGetPayload<T>> : Prisma__relatorio_operacaoClient<relatorio_operacaoGetPayload<T> | null, null>

    /**
     * Find the first Relatorio_operacao that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relatorio_operacaoFindFirstOrThrowArgs} args - Arguments to find a Relatorio_operacao
     * @example
     * // Get one Relatorio_operacao
     * const relatorio_operacao = await prisma.relatorio_operacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends relatorio_operacaoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, relatorio_operacaoFindFirstOrThrowArgs>
    ): Prisma__relatorio_operacaoClient<relatorio_operacaoGetPayload<T>>

    /**
     * Find zero or more Relatorio_operacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relatorio_operacaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Relatorio_operacaos
     * const relatorio_operacaos = await prisma.relatorio_operacao.findMany()
     * 
     * // Get first 10 Relatorio_operacaos
     * const relatorio_operacaos = await prisma.relatorio_operacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relatorio_operacaoWithIdOnly = await prisma.relatorio_operacao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends relatorio_operacaoFindManyArgs>(
      args?: SelectSubset<T, relatorio_operacaoFindManyArgs>
    ): Prisma.PrismaPromise<Array<relatorio_operacaoGetPayload<T>>>

    /**
     * Create a Relatorio_operacao.
     * @param {relatorio_operacaoCreateArgs} args - Arguments to create a Relatorio_operacao.
     * @example
     * // Create one Relatorio_operacao
     * const Relatorio_operacao = await prisma.relatorio_operacao.create({
     *   data: {
     *     // ... data to create a Relatorio_operacao
     *   }
     * })
     * 
    **/
    create<T extends relatorio_operacaoCreateArgs>(
      args: SelectSubset<T, relatorio_operacaoCreateArgs>
    ): Prisma__relatorio_operacaoClient<relatorio_operacaoGetPayload<T>>

    /**
     * Create many Relatorio_operacaos.
     *     @param {relatorio_operacaoCreateManyArgs} args - Arguments to create many Relatorio_operacaos.
     *     @example
     *     // Create many Relatorio_operacaos
     *     const relatorio_operacao = await prisma.relatorio_operacao.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends relatorio_operacaoCreateManyArgs>(
      args?: SelectSubset<T, relatorio_operacaoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Relatorio_operacao.
     * @param {relatorio_operacaoDeleteArgs} args - Arguments to delete one Relatorio_operacao.
     * @example
     * // Delete one Relatorio_operacao
     * const Relatorio_operacao = await prisma.relatorio_operacao.delete({
     *   where: {
     *     // ... filter to delete one Relatorio_operacao
     *   }
     * })
     * 
    **/
    delete<T extends relatorio_operacaoDeleteArgs>(
      args: SelectSubset<T, relatorio_operacaoDeleteArgs>
    ): Prisma__relatorio_operacaoClient<relatorio_operacaoGetPayload<T>>

    /**
     * Update one Relatorio_operacao.
     * @param {relatorio_operacaoUpdateArgs} args - Arguments to update one Relatorio_operacao.
     * @example
     * // Update one Relatorio_operacao
     * const relatorio_operacao = await prisma.relatorio_operacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends relatorio_operacaoUpdateArgs>(
      args: SelectSubset<T, relatorio_operacaoUpdateArgs>
    ): Prisma__relatorio_operacaoClient<relatorio_operacaoGetPayload<T>>

    /**
     * Delete zero or more Relatorio_operacaos.
     * @param {relatorio_operacaoDeleteManyArgs} args - Arguments to filter Relatorio_operacaos to delete.
     * @example
     * // Delete a few Relatorio_operacaos
     * const { count } = await prisma.relatorio_operacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends relatorio_operacaoDeleteManyArgs>(
      args?: SelectSubset<T, relatorio_operacaoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Relatorio_operacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relatorio_operacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Relatorio_operacaos
     * const relatorio_operacao = await prisma.relatorio_operacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends relatorio_operacaoUpdateManyArgs>(
      args: SelectSubset<T, relatorio_operacaoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Relatorio_operacao.
     * @param {relatorio_operacaoUpsertArgs} args - Arguments to update or create a Relatorio_operacao.
     * @example
     * // Update or create a Relatorio_operacao
     * const relatorio_operacao = await prisma.relatorio_operacao.upsert({
     *   create: {
     *     // ... data to create a Relatorio_operacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Relatorio_operacao we want to update
     *   }
     * })
    **/
    upsert<T extends relatorio_operacaoUpsertArgs>(
      args: SelectSubset<T, relatorio_operacaoUpsertArgs>
    ): Prisma__relatorio_operacaoClient<relatorio_operacaoGetPayload<T>>

    /**
     * Count the number of Relatorio_operacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {relatorio_operacaoCountArgs} args - Arguments to filter Relatorio_operacaos to count.
     * @example
     * // Count the number of Relatorio_operacaos
     * const count = await prisma.relatorio_operacao.count({
     *   where: {
     *     // ... the filter for the Relatorio_operacaos we want to count
     *   }
     * })
    **/
    count<T extends relatorio_operacaoCountArgs>(
      args?: Subset<T, relatorio_operacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Relatorio_operacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Relatorio_operacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Relatorio_operacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Relatorio_operacaoAggregateArgs>(args: Subset<T, Relatorio_operacaoAggregateArgs>): Prisma.PrismaPromise<GetRelatorio_operacaoAggregateType<T>>

    /**
     * Group by Relatorio_operacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Relatorio_operacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Relatorio_operacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Relatorio_operacaoGroupByArgs['orderBy'] }
        : { orderBy?: Relatorio_operacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Relatorio_operacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelatorio_operacaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for relatorio_operacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__relatorio_operacaoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    operacao<T extends operacoesArgs= {}>(args?: Subset<T, operacoesArgs>): Prisma__operacoesClient<operacoesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * relatorio_operacao base type for findUnique actions
   */
  export type relatorio_operacaoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the relatorio_operacao
     */
    select?: relatorio_operacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_operacaoInclude | null
    /**
     * Filter, which relatorio_operacao to fetch.
     */
    where: relatorio_operacaoWhereUniqueInput
  }

  /**
   * relatorio_operacao findUnique
   */
  export interface relatorio_operacaoFindUniqueArgs extends relatorio_operacaoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * relatorio_operacao findUniqueOrThrow
   */
  export type relatorio_operacaoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the relatorio_operacao
     */
    select?: relatorio_operacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_operacaoInclude | null
    /**
     * Filter, which relatorio_operacao to fetch.
     */
    where: relatorio_operacaoWhereUniqueInput
  }


  /**
   * relatorio_operacao base type for findFirst actions
   */
  export type relatorio_operacaoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the relatorio_operacao
     */
    select?: relatorio_operacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_operacaoInclude | null
    /**
     * Filter, which relatorio_operacao to fetch.
     */
    where?: relatorio_operacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relatorio_operacaos to fetch.
     */
    orderBy?: Enumerable<relatorio_operacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for relatorio_operacaos.
     */
    cursor?: relatorio_operacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relatorio_operacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relatorio_operacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of relatorio_operacaos.
     */
    distinct?: Enumerable<Relatorio_operacaoScalarFieldEnum>
  }

  /**
   * relatorio_operacao findFirst
   */
  export interface relatorio_operacaoFindFirstArgs extends relatorio_operacaoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * relatorio_operacao findFirstOrThrow
   */
  export type relatorio_operacaoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the relatorio_operacao
     */
    select?: relatorio_operacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_operacaoInclude | null
    /**
     * Filter, which relatorio_operacao to fetch.
     */
    where?: relatorio_operacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relatorio_operacaos to fetch.
     */
    orderBy?: Enumerable<relatorio_operacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for relatorio_operacaos.
     */
    cursor?: relatorio_operacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relatorio_operacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relatorio_operacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of relatorio_operacaos.
     */
    distinct?: Enumerable<Relatorio_operacaoScalarFieldEnum>
  }


  /**
   * relatorio_operacao findMany
   */
  export type relatorio_operacaoFindManyArgs = {
    /**
     * Select specific fields to fetch from the relatorio_operacao
     */
    select?: relatorio_operacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_operacaoInclude | null
    /**
     * Filter, which relatorio_operacaos to fetch.
     */
    where?: relatorio_operacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of relatorio_operacaos to fetch.
     */
    orderBy?: Enumerable<relatorio_operacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing relatorio_operacaos.
     */
    cursor?: relatorio_operacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` relatorio_operacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` relatorio_operacaos.
     */
    skip?: number
    distinct?: Enumerable<Relatorio_operacaoScalarFieldEnum>
  }


  /**
   * relatorio_operacao create
   */
  export type relatorio_operacaoCreateArgs = {
    /**
     * Select specific fields to fetch from the relatorio_operacao
     */
    select?: relatorio_operacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_operacaoInclude | null
    /**
     * The data needed to create a relatorio_operacao.
     */
    data: XOR<relatorio_operacaoCreateInput, relatorio_operacaoUncheckedCreateInput>
  }


  /**
   * relatorio_operacao createMany
   */
  export type relatorio_operacaoCreateManyArgs = {
    /**
     * The data used to create many relatorio_operacaos.
     */
    data: Enumerable<relatorio_operacaoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * relatorio_operacao update
   */
  export type relatorio_operacaoUpdateArgs = {
    /**
     * Select specific fields to fetch from the relatorio_operacao
     */
    select?: relatorio_operacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_operacaoInclude | null
    /**
     * The data needed to update a relatorio_operacao.
     */
    data: XOR<relatorio_operacaoUpdateInput, relatorio_operacaoUncheckedUpdateInput>
    /**
     * Choose, which relatorio_operacao to update.
     */
    where: relatorio_operacaoWhereUniqueInput
  }


  /**
   * relatorio_operacao updateMany
   */
  export type relatorio_operacaoUpdateManyArgs = {
    /**
     * The data used to update relatorio_operacaos.
     */
    data: XOR<relatorio_operacaoUpdateManyMutationInput, relatorio_operacaoUncheckedUpdateManyInput>
    /**
     * Filter which relatorio_operacaos to update
     */
    where?: relatorio_operacaoWhereInput
  }


  /**
   * relatorio_operacao upsert
   */
  export type relatorio_operacaoUpsertArgs = {
    /**
     * Select specific fields to fetch from the relatorio_operacao
     */
    select?: relatorio_operacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_operacaoInclude | null
    /**
     * The filter to search for the relatorio_operacao to update in case it exists.
     */
    where: relatorio_operacaoWhereUniqueInput
    /**
     * In case the relatorio_operacao found by the `where` argument doesn't exist, create a new relatorio_operacao with this data.
     */
    create: XOR<relatorio_operacaoCreateInput, relatorio_operacaoUncheckedCreateInput>
    /**
     * In case the relatorio_operacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<relatorio_operacaoUpdateInput, relatorio_operacaoUncheckedUpdateInput>
  }


  /**
   * relatorio_operacao delete
   */
  export type relatorio_operacaoDeleteArgs = {
    /**
     * Select specific fields to fetch from the relatorio_operacao
     */
    select?: relatorio_operacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_operacaoInclude | null
    /**
     * Filter which relatorio_operacao to delete.
     */
    where: relatorio_operacaoWhereUniqueInput
  }


  /**
   * relatorio_operacao deleteMany
   */
  export type relatorio_operacaoDeleteManyArgs = {
    /**
     * Filter which relatorio_operacaos to delete
     */
    where?: relatorio_operacaoWhereInput
  }


  /**
   * relatorio_operacao without action
   */
  export type relatorio_operacaoArgs = {
    /**
     * Select specific fields to fetch from the relatorio_operacao
     */
    select?: relatorio_operacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: relatorio_operacaoInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ManutencaoScalarFieldEnum: {
    id: 'id',
    veiculo: 'veiculo',
    data_inicio: 'data_inicio',
    valor: 'valor',
    descricao: 'descricao',
    data_fim: 'data_fim',
    concluidas: 'concluidas'
  };

  export type ManutencaoScalarFieldEnum = (typeof ManutencaoScalarFieldEnum)[keyof typeof ManutencaoScalarFieldEnum]


  export const MotoristaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    ocupado: 'ocupado'
  };

  export type MotoristaScalarFieldEnum = (typeof MotoristaScalarFieldEnum)[keyof typeof MotoristaScalarFieldEnum]


  export const OperacoesScalarFieldEnum: {
    id: 'id',
    veiculo: 'veiculo',
    motorista: 'motorista',
    data_saida: 'data_saida',
    descricao: 'descricao',
    data_retorno: 'data_retorno',
    concluidas: 'concluidas'
  };

  export type OperacoesScalarFieldEnum = (typeof OperacoesScalarFieldEnum)[keyof typeof OperacoesScalarFieldEnum]


  export const Relatorio_manutencaoScalarFieldEnum: {
    id: 'id',
    manutencao: 'manutencao'
  };

  export type Relatorio_manutencaoScalarFieldEnum = (typeof Relatorio_manutencaoScalarFieldEnum)[keyof typeof Relatorio_manutencaoScalarFieldEnum]


  export const Relatorio_operacaoScalarFieldEnum: {
    id: 'id',
    operacoes: 'operacoes'
  };

  export type Relatorio_operacaoScalarFieldEnum = (typeof Relatorio_operacaoScalarFieldEnum)[keyof typeof Relatorio_operacaoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const Tipo_veiculosScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo'
  };

  export type Tipo_veiculosScalarFieldEnum = (typeof Tipo_veiculosScalarFieldEnum)[keyof typeof Tipo_veiculosScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    senha: 'senha',
    nivel: 'nivel'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const VeiculosScalarFieldEnum: {
    id: 'id',
    placa: 'placa',
    tipo: 'tipo',
    uso: 'uso'
  };

  export type VeiculosScalarFieldEnum = (typeof VeiculosScalarFieldEnum)[keyof typeof VeiculosScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type usuarioWhereInput = {
    AND?: Enumerable<usuarioWhereInput>
    OR?: Enumerable<usuarioWhereInput>
    NOT?: Enumerable<usuarioWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
    email?: StringFilter | string
    senha?: StringFilter | string
    nivel?: IntFilter | number
  }

  export type usuarioOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel?: SortOrder
  }

  export type usuarioWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type usuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel?: SortOrder
    _count?: usuarioCountOrderByAggregateInput
    _avg?: usuarioAvgOrderByAggregateInput
    _max?: usuarioMaxOrderByAggregateInput
    _min?: usuarioMinOrderByAggregateInput
    _sum?: usuarioSumOrderByAggregateInput
  }

  export type usuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    senha?: StringWithAggregatesFilter | string
    nivel?: IntWithAggregatesFilter | number
  }

  export type motoristaWhereInput = {
    AND?: Enumerable<motoristaWhereInput>
    OR?: Enumerable<motoristaWhereInput>
    NOT?: Enumerable<motoristaWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
    ocupado?: BoolFilter | boolean
    operacoes?: OperacoesListRelationFilter
  }

  export type motoristaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    ocupado?: SortOrder
    operacoes?: operacoesOrderByRelationAggregateInput
  }

  export type motoristaWhereUniqueInput = {
    id?: number
  }

  export type motoristaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    ocupado?: SortOrder
    _count?: motoristaCountOrderByAggregateInput
    _avg?: motoristaAvgOrderByAggregateInput
    _max?: motoristaMaxOrderByAggregateInput
    _min?: motoristaMinOrderByAggregateInput
    _sum?: motoristaSumOrderByAggregateInput
  }

  export type motoristaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<motoristaScalarWhereWithAggregatesInput>
    OR?: Enumerable<motoristaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<motoristaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
    ocupado?: BoolWithAggregatesFilter | boolean
  }

  export type tipo_veiculosWhereInput = {
    AND?: Enumerable<tipo_veiculosWhereInput>
    OR?: Enumerable<tipo_veiculosWhereInput>
    NOT?: Enumerable<tipo_veiculosWhereInput>
    id?: IntFilter | number
    tipo?: StringFilter | string
    veiculos?: VeiculosListRelationFilter
  }

  export type tipo_veiculosOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    veiculos?: veiculosOrderByRelationAggregateInput
  }

  export type tipo_veiculosWhereUniqueInput = {
    id?: number
  }

  export type tipo_veiculosOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    _count?: tipo_veiculosCountOrderByAggregateInput
    _avg?: tipo_veiculosAvgOrderByAggregateInput
    _max?: tipo_veiculosMaxOrderByAggregateInput
    _min?: tipo_veiculosMinOrderByAggregateInput
    _sum?: tipo_veiculosSumOrderByAggregateInput
  }

  export type tipo_veiculosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tipo_veiculosScalarWhereWithAggregatesInput>
    OR?: Enumerable<tipo_veiculosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tipo_veiculosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    tipo?: StringWithAggregatesFilter | string
  }

  export type veiculosWhereInput = {
    AND?: Enumerable<veiculosWhereInput>
    OR?: Enumerable<veiculosWhereInput>
    NOT?: Enumerable<veiculosWhereInput>
    id?: IntFilter | number
    placa?: StringFilter | string
    tipo?: IntFilter | number
    uso?: BoolFilter | boolean
    manutencoes?: ManutencaoListRelationFilter
    operacoes?: OperacoesListRelationFilter
    tipos?: XOR<Tipo_veiculosRelationFilter, tipo_veiculosWhereInput>
  }

  export type veiculosOrderByWithRelationInput = {
    id?: SortOrder
    placa?: SortOrder
    tipo?: SortOrder
    uso?: SortOrder
    manutencoes?: manutencaoOrderByRelationAggregateInput
    operacoes?: operacoesOrderByRelationAggregateInput
    tipos?: tipo_veiculosOrderByWithRelationInput
  }

  export type veiculosWhereUniqueInput = {
    id?: number
    placa?: string
  }

  export type veiculosOrderByWithAggregationInput = {
    id?: SortOrder
    placa?: SortOrder
    tipo?: SortOrder
    uso?: SortOrder
    _count?: veiculosCountOrderByAggregateInput
    _avg?: veiculosAvgOrderByAggregateInput
    _max?: veiculosMaxOrderByAggregateInput
    _min?: veiculosMinOrderByAggregateInput
    _sum?: veiculosSumOrderByAggregateInput
  }

  export type veiculosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<veiculosScalarWhereWithAggregatesInput>
    OR?: Enumerable<veiculosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<veiculosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    placa?: StringWithAggregatesFilter | string
    tipo?: IntWithAggregatesFilter | number
    uso?: BoolWithAggregatesFilter | boolean
  }

  export type operacoesWhereInput = {
    AND?: Enumerable<operacoesWhereInput>
    OR?: Enumerable<operacoesWhereInput>
    NOT?: Enumerable<operacoesWhereInput>
    id?: IntFilter | number
    veiculo?: IntFilter | number
    motorista?: IntFilter | number
    data_saida?: DateTimeFilter | Date | string
    descricao?: StringFilter | string
    data_retorno?: DateTimeNullableFilter | Date | string | null
    concluidas?: BoolFilter | boolean
    relatorios?: Relatorio_operacaoListRelationFilter
    tipos?: XOR<VeiculosRelationFilter, veiculosWhereInput>
    motoristas?: XOR<MotoristaRelationFilter, motoristaWhereInput>
  }

  export type operacoesOrderByWithRelationInput = {
    id?: SortOrder
    veiculo?: SortOrder
    motorista?: SortOrder
    data_saida?: SortOrder
    descricao?: SortOrder
    data_retorno?: SortOrder
    concluidas?: SortOrder
    relatorios?: relatorio_operacaoOrderByRelationAggregateInput
    tipos?: veiculosOrderByWithRelationInput
    motoristas?: motoristaOrderByWithRelationInput
  }

  export type operacoesWhereUniqueInput = {
    id?: number
  }

  export type operacoesOrderByWithAggregationInput = {
    id?: SortOrder
    veiculo?: SortOrder
    motorista?: SortOrder
    data_saida?: SortOrder
    descricao?: SortOrder
    data_retorno?: SortOrder
    concluidas?: SortOrder
    _count?: operacoesCountOrderByAggregateInput
    _avg?: operacoesAvgOrderByAggregateInput
    _max?: operacoesMaxOrderByAggregateInput
    _min?: operacoesMinOrderByAggregateInput
    _sum?: operacoesSumOrderByAggregateInput
  }

  export type operacoesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<operacoesScalarWhereWithAggregatesInput>
    OR?: Enumerable<operacoesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<operacoesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    veiculo?: IntWithAggregatesFilter | number
    motorista?: IntWithAggregatesFilter | number
    data_saida?: DateTimeWithAggregatesFilter | Date | string
    descricao?: StringWithAggregatesFilter | string
    data_retorno?: DateTimeNullableWithAggregatesFilter | Date | string | null
    concluidas?: BoolWithAggregatesFilter | boolean
  }

  export type manutencaoWhereInput = {
    AND?: Enumerable<manutencaoWhereInput>
    OR?: Enumerable<manutencaoWhereInput>
    NOT?: Enumerable<manutencaoWhereInput>
    id?: IntFilter | number
    veiculo?: IntFilter | number
    data_inicio?: DateTimeFilter | Date | string
    valor?: FloatFilter | number
    descricao?: StringFilter | string
    data_fim?: DateTimeNullableFilter | Date | string | null
    concluidas?: BoolFilter | boolean
    manutencao?: Relatorio_manutencaoListRelationFilter
    veiculos?: XOR<VeiculosRelationFilter, veiculosWhereInput>
  }

  export type manutencaoOrderByWithRelationInput = {
    id?: SortOrder
    veiculo?: SortOrder
    data_inicio?: SortOrder
    valor?: SortOrder
    descricao?: SortOrder
    data_fim?: SortOrder
    concluidas?: SortOrder
    manutencao?: relatorio_manutencaoOrderByRelationAggregateInput
    veiculos?: veiculosOrderByWithRelationInput
  }

  export type manutencaoWhereUniqueInput = {
    id?: number
  }

  export type manutencaoOrderByWithAggregationInput = {
    id?: SortOrder
    veiculo?: SortOrder
    data_inicio?: SortOrder
    valor?: SortOrder
    descricao?: SortOrder
    data_fim?: SortOrder
    concluidas?: SortOrder
    _count?: manutencaoCountOrderByAggregateInput
    _avg?: manutencaoAvgOrderByAggregateInput
    _max?: manutencaoMaxOrderByAggregateInput
    _min?: manutencaoMinOrderByAggregateInput
    _sum?: manutencaoSumOrderByAggregateInput
  }

  export type manutencaoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<manutencaoScalarWhereWithAggregatesInput>
    OR?: Enumerable<manutencaoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<manutencaoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    veiculo?: IntWithAggregatesFilter | number
    data_inicio?: DateTimeWithAggregatesFilter | Date | string
    valor?: FloatWithAggregatesFilter | number
    descricao?: StringWithAggregatesFilter | string
    data_fim?: DateTimeNullableWithAggregatesFilter | Date | string | null
    concluidas?: BoolWithAggregatesFilter | boolean
  }

  export type relatorio_manutencaoWhereInput = {
    AND?: Enumerable<relatorio_manutencaoWhereInput>
    OR?: Enumerable<relatorio_manutencaoWhereInput>
    NOT?: Enumerable<relatorio_manutencaoWhereInput>
    id?: IntFilter | number
    manutencao?: IntFilter | number
    manutencoes?: XOR<ManutencaoRelationFilter, manutencaoWhereInput>
  }

  export type relatorio_manutencaoOrderByWithRelationInput = {
    id?: SortOrder
    manutencao?: SortOrder
    manutencoes?: manutencaoOrderByWithRelationInput
  }

  export type relatorio_manutencaoWhereUniqueInput = {
    id?: number
  }

  export type relatorio_manutencaoOrderByWithAggregationInput = {
    id?: SortOrder
    manutencao?: SortOrder
    _count?: relatorio_manutencaoCountOrderByAggregateInput
    _avg?: relatorio_manutencaoAvgOrderByAggregateInput
    _max?: relatorio_manutencaoMaxOrderByAggregateInput
    _min?: relatorio_manutencaoMinOrderByAggregateInput
    _sum?: relatorio_manutencaoSumOrderByAggregateInput
  }

  export type relatorio_manutencaoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<relatorio_manutencaoScalarWhereWithAggregatesInput>
    OR?: Enumerable<relatorio_manutencaoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<relatorio_manutencaoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    manutencao?: IntWithAggregatesFilter | number
  }

  export type relatorio_operacaoWhereInput = {
    AND?: Enumerable<relatorio_operacaoWhereInput>
    OR?: Enumerable<relatorio_operacaoWhereInput>
    NOT?: Enumerable<relatorio_operacaoWhereInput>
    id?: IntFilter | number
    operacoes?: IntFilter | number
    operacao?: XOR<OperacoesRelationFilter, operacoesWhereInput>
  }

  export type relatorio_operacaoOrderByWithRelationInput = {
    id?: SortOrder
    operacoes?: SortOrder
    operacao?: operacoesOrderByWithRelationInput
  }

  export type relatorio_operacaoWhereUniqueInput = {
    id?: number
  }

  export type relatorio_operacaoOrderByWithAggregationInput = {
    id?: SortOrder
    operacoes?: SortOrder
    _count?: relatorio_operacaoCountOrderByAggregateInput
    _avg?: relatorio_operacaoAvgOrderByAggregateInput
    _max?: relatorio_operacaoMaxOrderByAggregateInput
    _min?: relatorio_operacaoMinOrderByAggregateInput
    _sum?: relatorio_operacaoSumOrderByAggregateInput
  }

  export type relatorio_operacaoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<relatorio_operacaoScalarWhereWithAggregatesInput>
    OR?: Enumerable<relatorio_operacaoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<relatorio_operacaoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    operacoes?: IntWithAggregatesFilter | number
  }

  export type usuarioCreateInput = {
    nome: string
    email: string
    senha: string
    nivel: number
  }

  export type usuarioUncheckedCreateInput = {
    id?: number
    nome: string
    email: string
    senha: string
    nivel: number
  }

  export type usuarioUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
  }

  export type usuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
  }

  export type usuarioCreateManyInput = {
    id?: number
    nome: string
    email: string
    senha: string
    nivel: number
  }

  export type usuarioUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
  }

  export type usuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    nivel?: IntFieldUpdateOperationsInput | number
  }

  export type motoristaCreateInput = {
    nome: string
    ocupado?: boolean
    operacoes?: operacoesCreateNestedManyWithoutMotoristasInput
  }

  export type motoristaUncheckedCreateInput = {
    id?: number
    nome: string
    ocupado?: boolean
    operacoes?: operacoesUncheckedCreateNestedManyWithoutMotoristasInput
  }

  export type motoristaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ocupado?: BoolFieldUpdateOperationsInput | boolean
    operacoes?: operacoesUpdateManyWithoutMotoristasNestedInput
  }

  export type motoristaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ocupado?: BoolFieldUpdateOperationsInput | boolean
    operacoes?: operacoesUncheckedUpdateManyWithoutMotoristasNestedInput
  }

  export type motoristaCreateManyInput = {
    id?: number
    nome: string
    ocupado?: boolean
  }

  export type motoristaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ocupado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type motoristaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ocupado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tipo_veiculosCreateInput = {
    tipo: string
    veiculos?: veiculosCreateNestedManyWithoutTiposInput
  }

  export type tipo_veiculosUncheckedCreateInput = {
    id?: number
    tipo: string
    veiculos?: veiculosUncheckedCreateNestedManyWithoutTiposInput
  }

  export type tipo_veiculosUpdateInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    veiculos?: veiculosUpdateManyWithoutTiposNestedInput
  }

  export type tipo_veiculosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    veiculos?: veiculosUncheckedUpdateManyWithoutTiposNestedInput
  }

  export type tipo_veiculosCreateManyInput = {
    id?: number
    tipo: string
  }

  export type tipo_veiculosUpdateManyMutationInput = {
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type tipo_veiculosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type veiculosCreateInput = {
    placa: string
    uso?: boolean
    manutencoes?: manutencaoCreateNestedManyWithoutVeiculosInput
    operacoes?: operacoesCreateNestedManyWithoutTiposInput
    tipos: tipo_veiculosCreateNestedOneWithoutVeiculosInput
  }

  export type veiculosUncheckedCreateInput = {
    id?: number
    placa: string
    tipo: number
    uso?: boolean
    manutencoes?: manutencaoUncheckedCreateNestedManyWithoutVeiculosInput
    operacoes?: operacoesUncheckedCreateNestedManyWithoutTiposInput
  }

  export type veiculosUpdateInput = {
    placa?: StringFieldUpdateOperationsInput | string
    uso?: BoolFieldUpdateOperationsInput | boolean
    manutencoes?: manutencaoUpdateManyWithoutVeiculosNestedInput
    operacoes?: operacoesUpdateManyWithoutTiposNestedInput
    tipos?: tipo_veiculosUpdateOneRequiredWithoutVeiculosNestedInput
  }

  export type veiculosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    placa?: StringFieldUpdateOperationsInput | string
    tipo?: IntFieldUpdateOperationsInput | number
    uso?: BoolFieldUpdateOperationsInput | boolean
    manutencoes?: manutencaoUncheckedUpdateManyWithoutVeiculosNestedInput
    operacoes?: operacoesUncheckedUpdateManyWithoutTiposNestedInput
  }

  export type veiculosCreateManyInput = {
    id?: number
    placa: string
    tipo: number
    uso?: boolean
  }

  export type veiculosUpdateManyMutationInput = {
    placa?: StringFieldUpdateOperationsInput | string
    uso?: BoolFieldUpdateOperationsInput | boolean
  }

  export type veiculosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    placa?: StringFieldUpdateOperationsInput | string
    tipo?: IntFieldUpdateOperationsInput | number
    uso?: BoolFieldUpdateOperationsInput | boolean
  }

  export type operacoesCreateInput = {
    data_saida?: Date | string
    descricao: string
    data_retorno?: Date | string | null
    concluidas?: boolean
    relatorios?: relatorio_operacaoCreateNestedManyWithoutOperacaoInput
    tipos: veiculosCreateNestedOneWithoutOperacoesInput
    motoristas: motoristaCreateNestedOneWithoutOperacoesInput
  }

  export type operacoesUncheckedCreateInput = {
    id?: number
    veiculo: number
    motorista: number
    data_saida?: Date | string
    descricao: string
    data_retorno?: Date | string | null
    concluidas?: boolean
    relatorios?: relatorio_operacaoUncheckedCreateNestedManyWithoutOperacaoInput
  }

  export type operacoesUpdateInput = {
    data_saida?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    data_retorno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
    relatorios?: relatorio_operacaoUpdateManyWithoutOperacaoNestedInput
    tipos?: veiculosUpdateOneRequiredWithoutOperacoesNestedInput
    motoristas?: motoristaUpdateOneRequiredWithoutOperacoesNestedInput
  }

  export type operacoesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    veiculo?: IntFieldUpdateOperationsInput | number
    motorista?: IntFieldUpdateOperationsInput | number
    data_saida?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    data_retorno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
    relatorios?: relatorio_operacaoUncheckedUpdateManyWithoutOperacaoNestedInput
  }

  export type operacoesCreateManyInput = {
    id?: number
    veiculo: number
    motorista: number
    data_saida?: Date | string
    descricao: string
    data_retorno?: Date | string | null
    concluidas?: boolean
  }

  export type operacoesUpdateManyMutationInput = {
    data_saida?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    data_retorno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
  }

  export type operacoesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    veiculo?: IntFieldUpdateOperationsInput | number
    motorista?: IntFieldUpdateOperationsInput | number
    data_saida?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    data_retorno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
  }

  export type manutencaoCreateInput = {
    data_inicio?: Date | string
    valor: number
    descricao: string
    data_fim?: Date | string | null
    concluidas?: boolean
    manutencao?: relatorio_manutencaoCreateNestedManyWithoutManutencoesInput
    veiculos: veiculosCreateNestedOneWithoutManutencoesInput
  }

  export type manutencaoUncheckedCreateInput = {
    id?: number
    veiculo: number
    data_inicio?: Date | string
    valor: number
    descricao: string
    data_fim?: Date | string | null
    concluidas?: boolean
    manutencao?: relatorio_manutencaoUncheckedCreateNestedManyWithoutManutencoesInput
  }

  export type manutencaoUpdateInput = {
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    data_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
    manutencao?: relatorio_manutencaoUpdateManyWithoutManutencoesNestedInput
    veiculos?: veiculosUpdateOneRequiredWithoutManutencoesNestedInput
  }

  export type manutencaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    veiculo?: IntFieldUpdateOperationsInput | number
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    data_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
    manutencao?: relatorio_manutencaoUncheckedUpdateManyWithoutManutencoesNestedInput
  }

  export type manutencaoCreateManyInput = {
    id?: number
    veiculo: number
    data_inicio?: Date | string
    valor: number
    descricao: string
    data_fim?: Date | string | null
    concluidas?: boolean
  }

  export type manutencaoUpdateManyMutationInput = {
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    data_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
  }

  export type manutencaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    veiculo?: IntFieldUpdateOperationsInput | number
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    data_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
  }

  export type relatorio_manutencaoCreateInput = {
    manutencoes: manutencaoCreateNestedOneWithoutManutencaoInput
  }

  export type relatorio_manutencaoUncheckedCreateInput = {
    id?: number
    manutencao: number
  }

  export type relatorio_manutencaoUpdateInput = {
    manutencoes?: manutencaoUpdateOneRequiredWithoutManutencaoNestedInput
  }

  export type relatorio_manutencaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    manutencao?: IntFieldUpdateOperationsInput | number
  }

  export type relatorio_manutencaoCreateManyInput = {
    id?: number
    manutencao: number
  }

  export type relatorio_manutencaoUpdateManyMutationInput = {

  }

  export type relatorio_manutencaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    manutencao?: IntFieldUpdateOperationsInput | number
  }

  export type relatorio_operacaoCreateInput = {
    operacao: operacoesCreateNestedOneWithoutRelatoriosInput
  }

  export type relatorio_operacaoUncheckedCreateInput = {
    id?: number
    operacoes: number
  }

  export type relatorio_operacaoUpdateInput = {
    operacao?: operacoesUpdateOneRequiredWithoutRelatoriosNestedInput
  }

  export type relatorio_operacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    operacoes?: IntFieldUpdateOperationsInput | number
  }

  export type relatorio_operacaoCreateManyInput = {
    id?: number
    operacoes: number
  }

  export type relatorio_operacaoUpdateManyMutationInput = {

  }

  export type relatorio_operacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    operacoes?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type usuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel?: SortOrder
  }

  export type usuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    nivel?: SortOrder
  }

  export type usuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel?: SortOrder
  }

  export type usuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    nivel?: SortOrder
  }

  export type usuarioSumOrderByAggregateInput = {
    id?: SortOrder
    nivel?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type OperacoesListRelationFilter = {
    every?: operacoesWhereInput
    some?: operacoesWhereInput
    none?: operacoesWhereInput
  }

  export type operacoesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type motoristaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ocupado?: SortOrder
  }

  export type motoristaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type motoristaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ocupado?: SortOrder
  }

  export type motoristaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ocupado?: SortOrder
  }

  export type motoristaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type VeiculosListRelationFilter = {
    every?: veiculosWhereInput
    some?: veiculosWhereInput
    none?: veiculosWhereInput
  }

  export type veiculosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tipo_veiculosCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
  }

  export type tipo_veiculosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tipo_veiculosMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
  }

  export type tipo_veiculosMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
  }

  export type tipo_veiculosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ManutencaoListRelationFilter = {
    every?: manutencaoWhereInput
    some?: manutencaoWhereInput
    none?: manutencaoWhereInput
  }

  export type Tipo_veiculosRelationFilter = {
    is?: tipo_veiculosWhereInput
    isNot?: tipo_veiculosWhereInput
  }

  export type manutencaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type veiculosCountOrderByAggregateInput = {
    id?: SortOrder
    placa?: SortOrder
    tipo?: SortOrder
    uso?: SortOrder
  }

  export type veiculosAvgOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
  }

  export type veiculosMaxOrderByAggregateInput = {
    id?: SortOrder
    placa?: SortOrder
    tipo?: SortOrder
    uso?: SortOrder
  }

  export type veiculosMinOrderByAggregateInput = {
    id?: SortOrder
    placa?: SortOrder
    tipo?: SortOrder
    uso?: SortOrder
  }

  export type veiculosSumOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type Relatorio_operacaoListRelationFilter = {
    every?: relatorio_operacaoWhereInput
    some?: relatorio_operacaoWhereInput
    none?: relatorio_operacaoWhereInput
  }

  export type VeiculosRelationFilter = {
    is?: veiculosWhereInput
    isNot?: veiculosWhereInput
  }

  export type MotoristaRelationFilter = {
    is?: motoristaWhereInput
    isNot?: motoristaWhereInput
  }

  export type relatorio_operacaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type operacoesCountOrderByAggregateInput = {
    id?: SortOrder
    veiculo?: SortOrder
    motorista?: SortOrder
    data_saida?: SortOrder
    descricao?: SortOrder
    data_retorno?: SortOrder
    concluidas?: SortOrder
  }

  export type operacoesAvgOrderByAggregateInput = {
    id?: SortOrder
    veiculo?: SortOrder
    motorista?: SortOrder
  }

  export type operacoesMaxOrderByAggregateInput = {
    id?: SortOrder
    veiculo?: SortOrder
    motorista?: SortOrder
    data_saida?: SortOrder
    descricao?: SortOrder
    data_retorno?: SortOrder
    concluidas?: SortOrder
  }

  export type operacoesMinOrderByAggregateInput = {
    id?: SortOrder
    veiculo?: SortOrder
    motorista?: SortOrder
    data_saida?: SortOrder
    descricao?: SortOrder
    data_retorno?: SortOrder
    concluidas?: SortOrder
  }

  export type operacoesSumOrderByAggregateInput = {
    id?: SortOrder
    veiculo?: SortOrder
    motorista?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type Relatorio_manutencaoListRelationFilter = {
    every?: relatorio_manutencaoWhereInput
    some?: relatorio_manutencaoWhereInput
    none?: relatorio_manutencaoWhereInput
  }

  export type relatorio_manutencaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type manutencaoCountOrderByAggregateInput = {
    id?: SortOrder
    veiculo?: SortOrder
    data_inicio?: SortOrder
    valor?: SortOrder
    descricao?: SortOrder
    data_fim?: SortOrder
    concluidas?: SortOrder
  }

  export type manutencaoAvgOrderByAggregateInput = {
    id?: SortOrder
    veiculo?: SortOrder
    valor?: SortOrder
  }

  export type manutencaoMaxOrderByAggregateInput = {
    id?: SortOrder
    veiculo?: SortOrder
    data_inicio?: SortOrder
    valor?: SortOrder
    descricao?: SortOrder
    data_fim?: SortOrder
    concluidas?: SortOrder
  }

  export type manutencaoMinOrderByAggregateInput = {
    id?: SortOrder
    veiculo?: SortOrder
    data_inicio?: SortOrder
    valor?: SortOrder
    descricao?: SortOrder
    data_fim?: SortOrder
    concluidas?: SortOrder
  }

  export type manutencaoSumOrderByAggregateInput = {
    id?: SortOrder
    veiculo?: SortOrder
    valor?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type ManutencaoRelationFilter = {
    is?: manutencaoWhereInput
    isNot?: manutencaoWhereInput
  }

  export type relatorio_manutencaoCountOrderByAggregateInput = {
    id?: SortOrder
    manutencao?: SortOrder
  }

  export type relatorio_manutencaoAvgOrderByAggregateInput = {
    id?: SortOrder
    manutencao?: SortOrder
  }

  export type relatorio_manutencaoMaxOrderByAggregateInput = {
    id?: SortOrder
    manutencao?: SortOrder
  }

  export type relatorio_manutencaoMinOrderByAggregateInput = {
    id?: SortOrder
    manutencao?: SortOrder
  }

  export type relatorio_manutencaoSumOrderByAggregateInput = {
    id?: SortOrder
    manutencao?: SortOrder
  }

  export type OperacoesRelationFilter = {
    is?: operacoesWhereInput
    isNot?: operacoesWhereInput
  }

  export type relatorio_operacaoCountOrderByAggregateInput = {
    id?: SortOrder
    operacoes?: SortOrder
  }

  export type relatorio_operacaoAvgOrderByAggregateInput = {
    id?: SortOrder
    operacoes?: SortOrder
  }

  export type relatorio_operacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    operacoes?: SortOrder
  }

  export type relatorio_operacaoMinOrderByAggregateInput = {
    id?: SortOrder
    operacoes?: SortOrder
  }

  export type relatorio_operacaoSumOrderByAggregateInput = {
    id?: SortOrder
    operacoes?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type operacoesCreateNestedManyWithoutMotoristasInput = {
    create?: XOR<Enumerable<operacoesCreateWithoutMotoristasInput>, Enumerable<operacoesUncheckedCreateWithoutMotoristasInput>>
    connectOrCreate?: Enumerable<operacoesCreateOrConnectWithoutMotoristasInput>
    createMany?: operacoesCreateManyMotoristasInputEnvelope
    connect?: Enumerable<operacoesWhereUniqueInput>
  }

  export type operacoesUncheckedCreateNestedManyWithoutMotoristasInput = {
    create?: XOR<Enumerable<operacoesCreateWithoutMotoristasInput>, Enumerable<operacoesUncheckedCreateWithoutMotoristasInput>>
    connectOrCreate?: Enumerable<operacoesCreateOrConnectWithoutMotoristasInput>
    createMany?: operacoesCreateManyMotoristasInputEnvelope
    connect?: Enumerable<operacoesWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type operacoesUpdateManyWithoutMotoristasNestedInput = {
    create?: XOR<Enumerable<operacoesCreateWithoutMotoristasInput>, Enumerable<operacoesUncheckedCreateWithoutMotoristasInput>>
    connectOrCreate?: Enumerable<operacoesCreateOrConnectWithoutMotoristasInput>
    upsert?: Enumerable<operacoesUpsertWithWhereUniqueWithoutMotoristasInput>
    createMany?: operacoesCreateManyMotoristasInputEnvelope
    set?: Enumerable<operacoesWhereUniqueInput>
    disconnect?: Enumerable<operacoesWhereUniqueInput>
    delete?: Enumerable<operacoesWhereUniqueInput>
    connect?: Enumerable<operacoesWhereUniqueInput>
    update?: Enumerable<operacoesUpdateWithWhereUniqueWithoutMotoristasInput>
    updateMany?: Enumerable<operacoesUpdateManyWithWhereWithoutMotoristasInput>
    deleteMany?: Enumerable<operacoesScalarWhereInput>
  }

  export type operacoesUncheckedUpdateManyWithoutMotoristasNestedInput = {
    create?: XOR<Enumerable<operacoesCreateWithoutMotoristasInput>, Enumerable<operacoesUncheckedCreateWithoutMotoristasInput>>
    connectOrCreate?: Enumerable<operacoesCreateOrConnectWithoutMotoristasInput>
    upsert?: Enumerable<operacoesUpsertWithWhereUniqueWithoutMotoristasInput>
    createMany?: operacoesCreateManyMotoristasInputEnvelope
    set?: Enumerable<operacoesWhereUniqueInput>
    disconnect?: Enumerable<operacoesWhereUniqueInput>
    delete?: Enumerable<operacoesWhereUniqueInput>
    connect?: Enumerable<operacoesWhereUniqueInput>
    update?: Enumerable<operacoesUpdateWithWhereUniqueWithoutMotoristasInput>
    updateMany?: Enumerable<operacoesUpdateManyWithWhereWithoutMotoristasInput>
    deleteMany?: Enumerable<operacoesScalarWhereInput>
  }

  export type veiculosCreateNestedManyWithoutTiposInput = {
    create?: XOR<Enumerable<veiculosCreateWithoutTiposInput>, Enumerable<veiculosUncheckedCreateWithoutTiposInput>>
    connectOrCreate?: Enumerable<veiculosCreateOrConnectWithoutTiposInput>
    createMany?: veiculosCreateManyTiposInputEnvelope
    connect?: Enumerable<veiculosWhereUniqueInput>
  }

  export type veiculosUncheckedCreateNestedManyWithoutTiposInput = {
    create?: XOR<Enumerable<veiculosCreateWithoutTiposInput>, Enumerable<veiculosUncheckedCreateWithoutTiposInput>>
    connectOrCreate?: Enumerable<veiculosCreateOrConnectWithoutTiposInput>
    createMany?: veiculosCreateManyTiposInputEnvelope
    connect?: Enumerable<veiculosWhereUniqueInput>
  }

  export type veiculosUpdateManyWithoutTiposNestedInput = {
    create?: XOR<Enumerable<veiculosCreateWithoutTiposInput>, Enumerable<veiculosUncheckedCreateWithoutTiposInput>>
    connectOrCreate?: Enumerable<veiculosCreateOrConnectWithoutTiposInput>
    upsert?: Enumerable<veiculosUpsertWithWhereUniqueWithoutTiposInput>
    createMany?: veiculosCreateManyTiposInputEnvelope
    set?: Enumerable<veiculosWhereUniqueInput>
    disconnect?: Enumerable<veiculosWhereUniqueInput>
    delete?: Enumerable<veiculosWhereUniqueInput>
    connect?: Enumerable<veiculosWhereUniqueInput>
    update?: Enumerable<veiculosUpdateWithWhereUniqueWithoutTiposInput>
    updateMany?: Enumerable<veiculosUpdateManyWithWhereWithoutTiposInput>
    deleteMany?: Enumerable<veiculosScalarWhereInput>
  }

  export type veiculosUncheckedUpdateManyWithoutTiposNestedInput = {
    create?: XOR<Enumerable<veiculosCreateWithoutTiposInput>, Enumerable<veiculosUncheckedCreateWithoutTiposInput>>
    connectOrCreate?: Enumerable<veiculosCreateOrConnectWithoutTiposInput>
    upsert?: Enumerable<veiculosUpsertWithWhereUniqueWithoutTiposInput>
    createMany?: veiculosCreateManyTiposInputEnvelope
    set?: Enumerable<veiculosWhereUniqueInput>
    disconnect?: Enumerable<veiculosWhereUniqueInput>
    delete?: Enumerable<veiculosWhereUniqueInput>
    connect?: Enumerable<veiculosWhereUniqueInput>
    update?: Enumerable<veiculosUpdateWithWhereUniqueWithoutTiposInput>
    updateMany?: Enumerable<veiculosUpdateManyWithWhereWithoutTiposInput>
    deleteMany?: Enumerable<veiculosScalarWhereInput>
  }

  export type manutencaoCreateNestedManyWithoutVeiculosInput = {
    create?: XOR<Enumerable<manutencaoCreateWithoutVeiculosInput>, Enumerable<manutencaoUncheckedCreateWithoutVeiculosInput>>
    connectOrCreate?: Enumerable<manutencaoCreateOrConnectWithoutVeiculosInput>
    createMany?: manutencaoCreateManyVeiculosInputEnvelope
    connect?: Enumerable<manutencaoWhereUniqueInput>
  }

  export type operacoesCreateNestedManyWithoutTiposInput = {
    create?: XOR<Enumerable<operacoesCreateWithoutTiposInput>, Enumerable<operacoesUncheckedCreateWithoutTiposInput>>
    connectOrCreate?: Enumerable<operacoesCreateOrConnectWithoutTiposInput>
    createMany?: operacoesCreateManyTiposInputEnvelope
    connect?: Enumerable<operacoesWhereUniqueInput>
  }

  export type tipo_veiculosCreateNestedOneWithoutVeiculosInput = {
    create?: XOR<tipo_veiculosCreateWithoutVeiculosInput, tipo_veiculosUncheckedCreateWithoutVeiculosInput>
    connectOrCreate?: tipo_veiculosCreateOrConnectWithoutVeiculosInput
    connect?: tipo_veiculosWhereUniqueInput
  }

  export type manutencaoUncheckedCreateNestedManyWithoutVeiculosInput = {
    create?: XOR<Enumerable<manutencaoCreateWithoutVeiculosInput>, Enumerable<manutencaoUncheckedCreateWithoutVeiculosInput>>
    connectOrCreate?: Enumerable<manutencaoCreateOrConnectWithoutVeiculosInput>
    createMany?: manutencaoCreateManyVeiculosInputEnvelope
    connect?: Enumerable<manutencaoWhereUniqueInput>
  }

  export type operacoesUncheckedCreateNestedManyWithoutTiposInput = {
    create?: XOR<Enumerable<operacoesCreateWithoutTiposInput>, Enumerable<operacoesUncheckedCreateWithoutTiposInput>>
    connectOrCreate?: Enumerable<operacoesCreateOrConnectWithoutTiposInput>
    createMany?: operacoesCreateManyTiposInputEnvelope
    connect?: Enumerable<operacoesWhereUniqueInput>
  }

  export type manutencaoUpdateManyWithoutVeiculosNestedInput = {
    create?: XOR<Enumerable<manutencaoCreateWithoutVeiculosInput>, Enumerable<manutencaoUncheckedCreateWithoutVeiculosInput>>
    connectOrCreate?: Enumerable<manutencaoCreateOrConnectWithoutVeiculosInput>
    upsert?: Enumerable<manutencaoUpsertWithWhereUniqueWithoutVeiculosInput>
    createMany?: manutencaoCreateManyVeiculosInputEnvelope
    set?: Enumerable<manutencaoWhereUniqueInput>
    disconnect?: Enumerable<manutencaoWhereUniqueInput>
    delete?: Enumerable<manutencaoWhereUniqueInput>
    connect?: Enumerable<manutencaoWhereUniqueInput>
    update?: Enumerable<manutencaoUpdateWithWhereUniqueWithoutVeiculosInput>
    updateMany?: Enumerable<manutencaoUpdateManyWithWhereWithoutVeiculosInput>
    deleteMany?: Enumerable<manutencaoScalarWhereInput>
  }

  export type operacoesUpdateManyWithoutTiposNestedInput = {
    create?: XOR<Enumerable<operacoesCreateWithoutTiposInput>, Enumerable<operacoesUncheckedCreateWithoutTiposInput>>
    connectOrCreate?: Enumerable<operacoesCreateOrConnectWithoutTiposInput>
    upsert?: Enumerable<operacoesUpsertWithWhereUniqueWithoutTiposInput>
    createMany?: operacoesCreateManyTiposInputEnvelope
    set?: Enumerable<operacoesWhereUniqueInput>
    disconnect?: Enumerable<operacoesWhereUniqueInput>
    delete?: Enumerable<operacoesWhereUniqueInput>
    connect?: Enumerable<operacoesWhereUniqueInput>
    update?: Enumerable<operacoesUpdateWithWhereUniqueWithoutTiposInput>
    updateMany?: Enumerable<operacoesUpdateManyWithWhereWithoutTiposInput>
    deleteMany?: Enumerable<operacoesScalarWhereInput>
  }

  export type tipo_veiculosUpdateOneRequiredWithoutVeiculosNestedInput = {
    create?: XOR<tipo_veiculosCreateWithoutVeiculosInput, tipo_veiculosUncheckedCreateWithoutVeiculosInput>
    connectOrCreate?: tipo_veiculosCreateOrConnectWithoutVeiculosInput
    upsert?: tipo_veiculosUpsertWithoutVeiculosInput
    connect?: tipo_veiculosWhereUniqueInput
    update?: XOR<tipo_veiculosUpdateWithoutVeiculosInput, tipo_veiculosUncheckedUpdateWithoutVeiculosInput>
  }

  export type manutencaoUncheckedUpdateManyWithoutVeiculosNestedInput = {
    create?: XOR<Enumerable<manutencaoCreateWithoutVeiculosInput>, Enumerable<manutencaoUncheckedCreateWithoutVeiculosInput>>
    connectOrCreate?: Enumerable<manutencaoCreateOrConnectWithoutVeiculosInput>
    upsert?: Enumerable<manutencaoUpsertWithWhereUniqueWithoutVeiculosInput>
    createMany?: manutencaoCreateManyVeiculosInputEnvelope
    set?: Enumerable<manutencaoWhereUniqueInput>
    disconnect?: Enumerable<manutencaoWhereUniqueInput>
    delete?: Enumerable<manutencaoWhereUniqueInput>
    connect?: Enumerable<manutencaoWhereUniqueInput>
    update?: Enumerable<manutencaoUpdateWithWhereUniqueWithoutVeiculosInput>
    updateMany?: Enumerable<manutencaoUpdateManyWithWhereWithoutVeiculosInput>
    deleteMany?: Enumerable<manutencaoScalarWhereInput>
  }

  export type operacoesUncheckedUpdateManyWithoutTiposNestedInput = {
    create?: XOR<Enumerable<operacoesCreateWithoutTiposInput>, Enumerable<operacoesUncheckedCreateWithoutTiposInput>>
    connectOrCreate?: Enumerable<operacoesCreateOrConnectWithoutTiposInput>
    upsert?: Enumerable<operacoesUpsertWithWhereUniqueWithoutTiposInput>
    createMany?: operacoesCreateManyTiposInputEnvelope
    set?: Enumerable<operacoesWhereUniqueInput>
    disconnect?: Enumerable<operacoesWhereUniqueInput>
    delete?: Enumerable<operacoesWhereUniqueInput>
    connect?: Enumerable<operacoesWhereUniqueInput>
    update?: Enumerable<operacoesUpdateWithWhereUniqueWithoutTiposInput>
    updateMany?: Enumerable<operacoesUpdateManyWithWhereWithoutTiposInput>
    deleteMany?: Enumerable<operacoesScalarWhereInput>
  }

  export type relatorio_operacaoCreateNestedManyWithoutOperacaoInput = {
    create?: XOR<Enumerable<relatorio_operacaoCreateWithoutOperacaoInput>, Enumerable<relatorio_operacaoUncheckedCreateWithoutOperacaoInput>>
    connectOrCreate?: Enumerable<relatorio_operacaoCreateOrConnectWithoutOperacaoInput>
    createMany?: relatorio_operacaoCreateManyOperacaoInputEnvelope
    connect?: Enumerable<relatorio_operacaoWhereUniqueInput>
  }

  export type veiculosCreateNestedOneWithoutOperacoesInput = {
    create?: XOR<veiculosCreateWithoutOperacoesInput, veiculosUncheckedCreateWithoutOperacoesInput>
    connectOrCreate?: veiculosCreateOrConnectWithoutOperacoesInput
    connect?: veiculosWhereUniqueInput
  }

  export type motoristaCreateNestedOneWithoutOperacoesInput = {
    create?: XOR<motoristaCreateWithoutOperacoesInput, motoristaUncheckedCreateWithoutOperacoesInput>
    connectOrCreate?: motoristaCreateOrConnectWithoutOperacoesInput
    connect?: motoristaWhereUniqueInput
  }

  export type relatorio_operacaoUncheckedCreateNestedManyWithoutOperacaoInput = {
    create?: XOR<Enumerable<relatorio_operacaoCreateWithoutOperacaoInput>, Enumerable<relatorio_operacaoUncheckedCreateWithoutOperacaoInput>>
    connectOrCreate?: Enumerable<relatorio_operacaoCreateOrConnectWithoutOperacaoInput>
    createMany?: relatorio_operacaoCreateManyOperacaoInputEnvelope
    connect?: Enumerable<relatorio_operacaoWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type relatorio_operacaoUpdateManyWithoutOperacaoNestedInput = {
    create?: XOR<Enumerable<relatorio_operacaoCreateWithoutOperacaoInput>, Enumerable<relatorio_operacaoUncheckedCreateWithoutOperacaoInput>>
    connectOrCreate?: Enumerable<relatorio_operacaoCreateOrConnectWithoutOperacaoInput>
    upsert?: Enumerable<relatorio_operacaoUpsertWithWhereUniqueWithoutOperacaoInput>
    createMany?: relatorio_operacaoCreateManyOperacaoInputEnvelope
    set?: Enumerable<relatorio_operacaoWhereUniqueInput>
    disconnect?: Enumerable<relatorio_operacaoWhereUniqueInput>
    delete?: Enumerable<relatorio_operacaoWhereUniqueInput>
    connect?: Enumerable<relatorio_operacaoWhereUniqueInput>
    update?: Enumerable<relatorio_operacaoUpdateWithWhereUniqueWithoutOperacaoInput>
    updateMany?: Enumerable<relatorio_operacaoUpdateManyWithWhereWithoutOperacaoInput>
    deleteMany?: Enumerable<relatorio_operacaoScalarWhereInput>
  }

  export type veiculosUpdateOneRequiredWithoutOperacoesNestedInput = {
    create?: XOR<veiculosCreateWithoutOperacoesInput, veiculosUncheckedCreateWithoutOperacoesInput>
    connectOrCreate?: veiculosCreateOrConnectWithoutOperacoesInput
    upsert?: veiculosUpsertWithoutOperacoesInput
    connect?: veiculosWhereUniqueInput
    update?: XOR<veiculosUpdateWithoutOperacoesInput, veiculosUncheckedUpdateWithoutOperacoesInput>
  }

  export type motoristaUpdateOneRequiredWithoutOperacoesNestedInput = {
    create?: XOR<motoristaCreateWithoutOperacoesInput, motoristaUncheckedCreateWithoutOperacoesInput>
    connectOrCreate?: motoristaCreateOrConnectWithoutOperacoesInput
    upsert?: motoristaUpsertWithoutOperacoesInput
    connect?: motoristaWhereUniqueInput
    update?: XOR<motoristaUpdateWithoutOperacoesInput, motoristaUncheckedUpdateWithoutOperacoesInput>
  }

  export type relatorio_operacaoUncheckedUpdateManyWithoutOperacaoNestedInput = {
    create?: XOR<Enumerable<relatorio_operacaoCreateWithoutOperacaoInput>, Enumerable<relatorio_operacaoUncheckedCreateWithoutOperacaoInput>>
    connectOrCreate?: Enumerable<relatorio_operacaoCreateOrConnectWithoutOperacaoInput>
    upsert?: Enumerable<relatorio_operacaoUpsertWithWhereUniqueWithoutOperacaoInput>
    createMany?: relatorio_operacaoCreateManyOperacaoInputEnvelope
    set?: Enumerable<relatorio_operacaoWhereUniqueInput>
    disconnect?: Enumerable<relatorio_operacaoWhereUniqueInput>
    delete?: Enumerable<relatorio_operacaoWhereUniqueInput>
    connect?: Enumerable<relatorio_operacaoWhereUniqueInput>
    update?: Enumerable<relatorio_operacaoUpdateWithWhereUniqueWithoutOperacaoInput>
    updateMany?: Enumerable<relatorio_operacaoUpdateManyWithWhereWithoutOperacaoInput>
    deleteMany?: Enumerable<relatorio_operacaoScalarWhereInput>
  }

  export type relatorio_manutencaoCreateNestedManyWithoutManutencoesInput = {
    create?: XOR<Enumerable<relatorio_manutencaoCreateWithoutManutencoesInput>, Enumerable<relatorio_manutencaoUncheckedCreateWithoutManutencoesInput>>
    connectOrCreate?: Enumerable<relatorio_manutencaoCreateOrConnectWithoutManutencoesInput>
    createMany?: relatorio_manutencaoCreateManyManutencoesInputEnvelope
    connect?: Enumerable<relatorio_manutencaoWhereUniqueInput>
  }

  export type veiculosCreateNestedOneWithoutManutencoesInput = {
    create?: XOR<veiculosCreateWithoutManutencoesInput, veiculosUncheckedCreateWithoutManutencoesInput>
    connectOrCreate?: veiculosCreateOrConnectWithoutManutencoesInput
    connect?: veiculosWhereUniqueInput
  }

  export type relatorio_manutencaoUncheckedCreateNestedManyWithoutManutencoesInput = {
    create?: XOR<Enumerable<relatorio_manutencaoCreateWithoutManutencoesInput>, Enumerable<relatorio_manutencaoUncheckedCreateWithoutManutencoesInput>>
    connectOrCreate?: Enumerable<relatorio_manutencaoCreateOrConnectWithoutManutencoesInput>
    createMany?: relatorio_manutencaoCreateManyManutencoesInputEnvelope
    connect?: Enumerable<relatorio_manutencaoWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type relatorio_manutencaoUpdateManyWithoutManutencoesNestedInput = {
    create?: XOR<Enumerable<relatorio_manutencaoCreateWithoutManutencoesInput>, Enumerable<relatorio_manutencaoUncheckedCreateWithoutManutencoesInput>>
    connectOrCreate?: Enumerable<relatorio_manutencaoCreateOrConnectWithoutManutencoesInput>
    upsert?: Enumerable<relatorio_manutencaoUpsertWithWhereUniqueWithoutManutencoesInput>
    createMany?: relatorio_manutencaoCreateManyManutencoesInputEnvelope
    set?: Enumerable<relatorio_manutencaoWhereUniqueInput>
    disconnect?: Enumerable<relatorio_manutencaoWhereUniqueInput>
    delete?: Enumerable<relatorio_manutencaoWhereUniqueInput>
    connect?: Enumerable<relatorio_manutencaoWhereUniqueInput>
    update?: Enumerable<relatorio_manutencaoUpdateWithWhereUniqueWithoutManutencoesInput>
    updateMany?: Enumerable<relatorio_manutencaoUpdateManyWithWhereWithoutManutencoesInput>
    deleteMany?: Enumerable<relatorio_manutencaoScalarWhereInput>
  }

  export type veiculosUpdateOneRequiredWithoutManutencoesNestedInput = {
    create?: XOR<veiculosCreateWithoutManutencoesInput, veiculosUncheckedCreateWithoutManutencoesInput>
    connectOrCreate?: veiculosCreateOrConnectWithoutManutencoesInput
    upsert?: veiculosUpsertWithoutManutencoesInput
    connect?: veiculosWhereUniqueInput
    update?: XOR<veiculosUpdateWithoutManutencoesInput, veiculosUncheckedUpdateWithoutManutencoesInput>
  }

  export type relatorio_manutencaoUncheckedUpdateManyWithoutManutencoesNestedInput = {
    create?: XOR<Enumerable<relatorio_manutencaoCreateWithoutManutencoesInput>, Enumerable<relatorio_manutencaoUncheckedCreateWithoutManutencoesInput>>
    connectOrCreate?: Enumerable<relatorio_manutencaoCreateOrConnectWithoutManutencoesInput>
    upsert?: Enumerable<relatorio_manutencaoUpsertWithWhereUniqueWithoutManutencoesInput>
    createMany?: relatorio_manutencaoCreateManyManutencoesInputEnvelope
    set?: Enumerable<relatorio_manutencaoWhereUniqueInput>
    disconnect?: Enumerable<relatorio_manutencaoWhereUniqueInput>
    delete?: Enumerable<relatorio_manutencaoWhereUniqueInput>
    connect?: Enumerable<relatorio_manutencaoWhereUniqueInput>
    update?: Enumerable<relatorio_manutencaoUpdateWithWhereUniqueWithoutManutencoesInput>
    updateMany?: Enumerable<relatorio_manutencaoUpdateManyWithWhereWithoutManutencoesInput>
    deleteMany?: Enumerable<relatorio_manutencaoScalarWhereInput>
  }

  export type manutencaoCreateNestedOneWithoutManutencaoInput = {
    create?: XOR<manutencaoCreateWithoutManutencaoInput, manutencaoUncheckedCreateWithoutManutencaoInput>
    connectOrCreate?: manutencaoCreateOrConnectWithoutManutencaoInput
    connect?: manutencaoWhereUniqueInput
  }

  export type manutencaoUpdateOneRequiredWithoutManutencaoNestedInput = {
    create?: XOR<manutencaoCreateWithoutManutencaoInput, manutencaoUncheckedCreateWithoutManutencaoInput>
    connectOrCreate?: manutencaoCreateOrConnectWithoutManutencaoInput
    upsert?: manutencaoUpsertWithoutManutencaoInput
    connect?: manutencaoWhereUniqueInput
    update?: XOR<manutencaoUpdateWithoutManutencaoInput, manutencaoUncheckedUpdateWithoutManutencaoInput>
  }

  export type operacoesCreateNestedOneWithoutRelatoriosInput = {
    create?: XOR<operacoesCreateWithoutRelatoriosInput, operacoesUncheckedCreateWithoutRelatoriosInput>
    connectOrCreate?: operacoesCreateOrConnectWithoutRelatoriosInput
    connect?: operacoesWhereUniqueInput
  }

  export type operacoesUpdateOneRequiredWithoutRelatoriosNestedInput = {
    create?: XOR<operacoesCreateWithoutRelatoriosInput, operacoesUncheckedCreateWithoutRelatoriosInput>
    connectOrCreate?: operacoesCreateOrConnectWithoutRelatoriosInput
    upsert?: operacoesUpsertWithoutRelatoriosInput
    connect?: operacoesWhereUniqueInput
    update?: XOR<operacoesUpdateWithoutRelatoriosInput, operacoesUncheckedUpdateWithoutRelatoriosInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type operacoesCreateWithoutMotoristasInput = {
    data_saida?: Date | string
    descricao: string
    data_retorno?: Date | string | null
    concluidas?: boolean
    relatorios?: relatorio_operacaoCreateNestedManyWithoutOperacaoInput
    tipos: veiculosCreateNestedOneWithoutOperacoesInput
  }

  export type operacoesUncheckedCreateWithoutMotoristasInput = {
    id?: number
    veiculo: number
    data_saida?: Date | string
    descricao: string
    data_retorno?: Date | string | null
    concluidas?: boolean
    relatorios?: relatorio_operacaoUncheckedCreateNestedManyWithoutOperacaoInput
  }

  export type operacoesCreateOrConnectWithoutMotoristasInput = {
    where: operacoesWhereUniqueInput
    create: XOR<operacoesCreateWithoutMotoristasInput, operacoesUncheckedCreateWithoutMotoristasInput>
  }

  export type operacoesCreateManyMotoristasInputEnvelope = {
    data: Enumerable<operacoesCreateManyMotoristasInput>
    skipDuplicates?: boolean
  }

  export type operacoesUpsertWithWhereUniqueWithoutMotoristasInput = {
    where: operacoesWhereUniqueInput
    update: XOR<operacoesUpdateWithoutMotoristasInput, operacoesUncheckedUpdateWithoutMotoristasInput>
    create: XOR<operacoesCreateWithoutMotoristasInput, operacoesUncheckedCreateWithoutMotoristasInput>
  }

  export type operacoesUpdateWithWhereUniqueWithoutMotoristasInput = {
    where: operacoesWhereUniqueInput
    data: XOR<operacoesUpdateWithoutMotoristasInput, operacoesUncheckedUpdateWithoutMotoristasInput>
  }

  export type operacoesUpdateManyWithWhereWithoutMotoristasInput = {
    where: operacoesScalarWhereInput
    data: XOR<operacoesUpdateManyMutationInput, operacoesUncheckedUpdateManyWithoutOperacoesInput>
  }

  export type operacoesScalarWhereInput = {
    AND?: Enumerable<operacoesScalarWhereInput>
    OR?: Enumerable<operacoesScalarWhereInput>
    NOT?: Enumerable<operacoesScalarWhereInput>
    id?: IntFilter | number
    veiculo?: IntFilter | number
    motorista?: IntFilter | number
    data_saida?: DateTimeFilter | Date | string
    descricao?: StringFilter | string
    data_retorno?: DateTimeNullableFilter | Date | string | null
    concluidas?: BoolFilter | boolean
  }

  export type veiculosCreateWithoutTiposInput = {
    placa: string
    uso?: boolean
    manutencoes?: manutencaoCreateNestedManyWithoutVeiculosInput
    operacoes?: operacoesCreateNestedManyWithoutTiposInput
  }

  export type veiculosUncheckedCreateWithoutTiposInput = {
    id?: number
    placa: string
    uso?: boolean
    manutencoes?: manutencaoUncheckedCreateNestedManyWithoutVeiculosInput
    operacoes?: operacoesUncheckedCreateNestedManyWithoutTiposInput
  }

  export type veiculosCreateOrConnectWithoutTiposInput = {
    where: veiculosWhereUniqueInput
    create: XOR<veiculosCreateWithoutTiposInput, veiculosUncheckedCreateWithoutTiposInput>
  }

  export type veiculosCreateManyTiposInputEnvelope = {
    data: Enumerable<veiculosCreateManyTiposInput>
    skipDuplicates?: boolean
  }

  export type veiculosUpsertWithWhereUniqueWithoutTiposInput = {
    where: veiculosWhereUniqueInput
    update: XOR<veiculosUpdateWithoutTiposInput, veiculosUncheckedUpdateWithoutTiposInput>
    create: XOR<veiculosCreateWithoutTiposInput, veiculosUncheckedCreateWithoutTiposInput>
  }

  export type veiculosUpdateWithWhereUniqueWithoutTiposInput = {
    where: veiculosWhereUniqueInput
    data: XOR<veiculosUpdateWithoutTiposInput, veiculosUncheckedUpdateWithoutTiposInput>
  }

  export type veiculosUpdateManyWithWhereWithoutTiposInput = {
    where: veiculosScalarWhereInput
    data: XOR<veiculosUpdateManyMutationInput, veiculosUncheckedUpdateManyWithoutVeiculosInput>
  }

  export type veiculosScalarWhereInput = {
    AND?: Enumerable<veiculosScalarWhereInput>
    OR?: Enumerable<veiculosScalarWhereInput>
    NOT?: Enumerable<veiculosScalarWhereInput>
    id?: IntFilter | number
    placa?: StringFilter | string
    tipo?: IntFilter | number
    uso?: BoolFilter | boolean
  }

  export type manutencaoCreateWithoutVeiculosInput = {
    data_inicio?: Date | string
    valor: number
    descricao: string
    data_fim?: Date | string | null
    concluidas?: boolean
    manutencao?: relatorio_manutencaoCreateNestedManyWithoutManutencoesInput
  }

  export type manutencaoUncheckedCreateWithoutVeiculosInput = {
    id?: number
    data_inicio?: Date | string
    valor: number
    descricao: string
    data_fim?: Date | string | null
    concluidas?: boolean
    manutencao?: relatorio_manutencaoUncheckedCreateNestedManyWithoutManutencoesInput
  }

  export type manutencaoCreateOrConnectWithoutVeiculosInput = {
    where: manutencaoWhereUniqueInput
    create: XOR<manutencaoCreateWithoutVeiculosInput, manutencaoUncheckedCreateWithoutVeiculosInput>
  }

  export type manutencaoCreateManyVeiculosInputEnvelope = {
    data: Enumerable<manutencaoCreateManyVeiculosInput>
    skipDuplicates?: boolean
  }

  export type operacoesCreateWithoutTiposInput = {
    data_saida?: Date | string
    descricao: string
    data_retorno?: Date | string | null
    concluidas?: boolean
    relatorios?: relatorio_operacaoCreateNestedManyWithoutOperacaoInput
    motoristas: motoristaCreateNestedOneWithoutOperacoesInput
  }

  export type operacoesUncheckedCreateWithoutTiposInput = {
    id?: number
    motorista: number
    data_saida?: Date | string
    descricao: string
    data_retorno?: Date | string | null
    concluidas?: boolean
    relatorios?: relatorio_operacaoUncheckedCreateNestedManyWithoutOperacaoInput
  }

  export type operacoesCreateOrConnectWithoutTiposInput = {
    where: operacoesWhereUniqueInput
    create: XOR<operacoesCreateWithoutTiposInput, operacoesUncheckedCreateWithoutTiposInput>
  }

  export type operacoesCreateManyTiposInputEnvelope = {
    data: Enumerable<operacoesCreateManyTiposInput>
    skipDuplicates?: boolean
  }

  export type tipo_veiculosCreateWithoutVeiculosInput = {
    tipo: string
  }

  export type tipo_veiculosUncheckedCreateWithoutVeiculosInput = {
    id?: number
    tipo: string
  }

  export type tipo_veiculosCreateOrConnectWithoutVeiculosInput = {
    where: tipo_veiculosWhereUniqueInput
    create: XOR<tipo_veiculosCreateWithoutVeiculosInput, tipo_veiculosUncheckedCreateWithoutVeiculosInput>
  }

  export type manutencaoUpsertWithWhereUniqueWithoutVeiculosInput = {
    where: manutencaoWhereUniqueInput
    update: XOR<manutencaoUpdateWithoutVeiculosInput, manutencaoUncheckedUpdateWithoutVeiculosInput>
    create: XOR<manutencaoCreateWithoutVeiculosInput, manutencaoUncheckedCreateWithoutVeiculosInput>
  }

  export type manutencaoUpdateWithWhereUniqueWithoutVeiculosInput = {
    where: manutencaoWhereUniqueInput
    data: XOR<manutencaoUpdateWithoutVeiculosInput, manutencaoUncheckedUpdateWithoutVeiculosInput>
  }

  export type manutencaoUpdateManyWithWhereWithoutVeiculosInput = {
    where: manutencaoScalarWhereInput
    data: XOR<manutencaoUpdateManyMutationInput, manutencaoUncheckedUpdateManyWithoutManutencoesInput>
  }

  export type manutencaoScalarWhereInput = {
    AND?: Enumerable<manutencaoScalarWhereInput>
    OR?: Enumerable<manutencaoScalarWhereInput>
    NOT?: Enumerable<manutencaoScalarWhereInput>
    id?: IntFilter | number
    veiculo?: IntFilter | number
    data_inicio?: DateTimeFilter | Date | string
    valor?: FloatFilter | number
    descricao?: StringFilter | string
    data_fim?: DateTimeNullableFilter | Date | string | null
    concluidas?: BoolFilter | boolean
  }

  export type operacoesUpsertWithWhereUniqueWithoutTiposInput = {
    where: operacoesWhereUniqueInput
    update: XOR<operacoesUpdateWithoutTiposInput, operacoesUncheckedUpdateWithoutTiposInput>
    create: XOR<operacoesCreateWithoutTiposInput, operacoesUncheckedCreateWithoutTiposInput>
  }

  export type operacoesUpdateWithWhereUniqueWithoutTiposInput = {
    where: operacoesWhereUniqueInput
    data: XOR<operacoesUpdateWithoutTiposInput, operacoesUncheckedUpdateWithoutTiposInput>
  }

  export type operacoesUpdateManyWithWhereWithoutTiposInput = {
    where: operacoesScalarWhereInput
    data: XOR<operacoesUpdateManyMutationInput, operacoesUncheckedUpdateManyWithoutOperacoesInput>
  }

  export type tipo_veiculosUpsertWithoutVeiculosInput = {
    update: XOR<tipo_veiculosUpdateWithoutVeiculosInput, tipo_veiculosUncheckedUpdateWithoutVeiculosInput>
    create: XOR<tipo_veiculosCreateWithoutVeiculosInput, tipo_veiculosUncheckedCreateWithoutVeiculosInput>
  }

  export type tipo_veiculosUpdateWithoutVeiculosInput = {
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type tipo_veiculosUncheckedUpdateWithoutVeiculosInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type relatorio_operacaoCreateWithoutOperacaoInput = {

  }

  export type relatorio_operacaoUncheckedCreateWithoutOperacaoInput = {
    id?: number
  }

  export type relatorio_operacaoCreateOrConnectWithoutOperacaoInput = {
    where: relatorio_operacaoWhereUniqueInput
    create: XOR<relatorio_operacaoCreateWithoutOperacaoInput, relatorio_operacaoUncheckedCreateWithoutOperacaoInput>
  }

  export type relatorio_operacaoCreateManyOperacaoInputEnvelope = {
    data: Enumerable<relatorio_operacaoCreateManyOperacaoInput>
    skipDuplicates?: boolean
  }

  export type veiculosCreateWithoutOperacoesInput = {
    placa: string
    uso?: boolean
    manutencoes?: manutencaoCreateNestedManyWithoutVeiculosInput
    tipos: tipo_veiculosCreateNestedOneWithoutVeiculosInput
  }

  export type veiculosUncheckedCreateWithoutOperacoesInput = {
    id?: number
    placa: string
    tipo: number
    uso?: boolean
    manutencoes?: manutencaoUncheckedCreateNestedManyWithoutVeiculosInput
  }

  export type veiculosCreateOrConnectWithoutOperacoesInput = {
    where: veiculosWhereUniqueInput
    create: XOR<veiculosCreateWithoutOperacoesInput, veiculosUncheckedCreateWithoutOperacoesInput>
  }

  export type motoristaCreateWithoutOperacoesInput = {
    nome: string
    ocupado?: boolean
  }

  export type motoristaUncheckedCreateWithoutOperacoesInput = {
    id?: number
    nome: string
    ocupado?: boolean
  }

  export type motoristaCreateOrConnectWithoutOperacoesInput = {
    where: motoristaWhereUniqueInput
    create: XOR<motoristaCreateWithoutOperacoesInput, motoristaUncheckedCreateWithoutOperacoesInput>
  }

  export type relatorio_operacaoUpsertWithWhereUniqueWithoutOperacaoInput = {
    where: relatorio_operacaoWhereUniqueInput
    update: XOR<relatorio_operacaoUpdateWithoutOperacaoInput, relatorio_operacaoUncheckedUpdateWithoutOperacaoInput>
    create: XOR<relatorio_operacaoCreateWithoutOperacaoInput, relatorio_operacaoUncheckedCreateWithoutOperacaoInput>
  }

  export type relatorio_operacaoUpdateWithWhereUniqueWithoutOperacaoInput = {
    where: relatorio_operacaoWhereUniqueInput
    data: XOR<relatorio_operacaoUpdateWithoutOperacaoInput, relatorio_operacaoUncheckedUpdateWithoutOperacaoInput>
  }

  export type relatorio_operacaoUpdateManyWithWhereWithoutOperacaoInput = {
    where: relatorio_operacaoScalarWhereInput
    data: XOR<relatorio_operacaoUpdateManyMutationInput, relatorio_operacaoUncheckedUpdateManyWithoutRelatoriosInput>
  }

  export type relatorio_operacaoScalarWhereInput = {
    AND?: Enumerable<relatorio_operacaoScalarWhereInput>
    OR?: Enumerable<relatorio_operacaoScalarWhereInput>
    NOT?: Enumerable<relatorio_operacaoScalarWhereInput>
    id?: IntFilter | number
    operacoes?: IntFilter | number
  }

  export type veiculosUpsertWithoutOperacoesInput = {
    update: XOR<veiculosUpdateWithoutOperacoesInput, veiculosUncheckedUpdateWithoutOperacoesInput>
    create: XOR<veiculosCreateWithoutOperacoesInput, veiculosUncheckedCreateWithoutOperacoesInput>
  }

  export type veiculosUpdateWithoutOperacoesInput = {
    placa?: StringFieldUpdateOperationsInput | string
    uso?: BoolFieldUpdateOperationsInput | boolean
    manutencoes?: manutencaoUpdateManyWithoutVeiculosNestedInput
    tipos?: tipo_veiculosUpdateOneRequiredWithoutVeiculosNestedInput
  }

  export type veiculosUncheckedUpdateWithoutOperacoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    placa?: StringFieldUpdateOperationsInput | string
    tipo?: IntFieldUpdateOperationsInput | number
    uso?: BoolFieldUpdateOperationsInput | boolean
    manutencoes?: manutencaoUncheckedUpdateManyWithoutVeiculosNestedInput
  }

  export type motoristaUpsertWithoutOperacoesInput = {
    update: XOR<motoristaUpdateWithoutOperacoesInput, motoristaUncheckedUpdateWithoutOperacoesInput>
    create: XOR<motoristaCreateWithoutOperacoesInput, motoristaUncheckedCreateWithoutOperacoesInput>
  }

  export type motoristaUpdateWithoutOperacoesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ocupado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type motoristaUncheckedUpdateWithoutOperacoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ocupado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type relatorio_manutencaoCreateWithoutManutencoesInput = {

  }

  export type relatorio_manutencaoUncheckedCreateWithoutManutencoesInput = {
    id?: number
  }

  export type relatorio_manutencaoCreateOrConnectWithoutManutencoesInput = {
    where: relatorio_manutencaoWhereUniqueInput
    create: XOR<relatorio_manutencaoCreateWithoutManutencoesInput, relatorio_manutencaoUncheckedCreateWithoutManutencoesInput>
  }

  export type relatorio_manutencaoCreateManyManutencoesInputEnvelope = {
    data: Enumerable<relatorio_manutencaoCreateManyManutencoesInput>
    skipDuplicates?: boolean
  }

  export type veiculosCreateWithoutManutencoesInput = {
    placa: string
    uso?: boolean
    operacoes?: operacoesCreateNestedManyWithoutTiposInput
    tipos: tipo_veiculosCreateNestedOneWithoutVeiculosInput
  }

  export type veiculosUncheckedCreateWithoutManutencoesInput = {
    id?: number
    placa: string
    tipo: number
    uso?: boolean
    operacoes?: operacoesUncheckedCreateNestedManyWithoutTiposInput
  }

  export type veiculosCreateOrConnectWithoutManutencoesInput = {
    where: veiculosWhereUniqueInput
    create: XOR<veiculosCreateWithoutManutencoesInput, veiculosUncheckedCreateWithoutManutencoesInput>
  }

  export type relatorio_manutencaoUpsertWithWhereUniqueWithoutManutencoesInput = {
    where: relatorio_manutencaoWhereUniqueInput
    update: XOR<relatorio_manutencaoUpdateWithoutManutencoesInput, relatorio_manutencaoUncheckedUpdateWithoutManutencoesInput>
    create: XOR<relatorio_manutencaoCreateWithoutManutencoesInput, relatorio_manutencaoUncheckedCreateWithoutManutencoesInput>
  }

  export type relatorio_manutencaoUpdateWithWhereUniqueWithoutManutencoesInput = {
    where: relatorio_manutencaoWhereUniqueInput
    data: XOR<relatorio_manutencaoUpdateWithoutManutencoesInput, relatorio_manutencaoUncheckedUpdateWithoutManutencoesInput>
  }

  export type relatorio_manutencaoUpdateManyWithWhereWithoutManutencoesInput = {
    where: relatorio_manutencaoScalarWhereInput
    data: XOR<relatorio_manutencaoUpdateManyMutationInput, relatorio_manutencaoUncheckedUpdateManyWithoutManutencaoInput>
  }

  export type relatorio_manutencaoScalarWhereInput = {
    AND?: Enumerable<relatorio_manutencaoScalarWhereInput>
    OR?: Enumerable<relatorio_manutencaoScalarWhereInput>
    NOT?: Enumerable<relatorio_manutencaoScalarWhereInput>
    id?: IntFilter | number
    manutencao?: IntFilter | number
  }

  export type veiculosUpsertWithoutManutencoesInput = {
    update: XOR<veiculosUpdateWithoutManutencoesInput, veiculosUncheckedUpdateWithoutManutencoesInput>
    create: XOR<veiculosCreateWithoutManutencoesInput, veiculosUncheckedCreateWithoutManutencoesInput>
  }

  export type veiculosUpdateWithoutManutencoesInput = {
    placa?: StringFieldUpdateOperationsInput | string
    uso?: BoolFieldUpdateOperationsInput | boolean
    operacoes?: operacoesUpdateManyWithoutTiposNestedInput
    tipos?: tipo_veiculosUpdateOneRequiredWithoutVeiculosNestedInput
  }

  export type veiculosUncheckedUpdateWithoutManutencoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    placa?: StringFieldUpdateOperationsInput | string
    tipo?: IntFieldUpdateOperationsInput | number
    uso?: BoolFieldUpdateOperationsInput | boolean
    operacoes?: operacoesUncheckedUpdateManyWithoutTiposNestedInput
  }

  export type manutencaoCreateWithoutManutencaoInput = {
    data_inicio?: Date | string
    valor: number
    descricao: string
    data_fim?: Date | string | null
    concluidas?: boolean
    veiculos: veiculosCreateNestedOneWithoutManutencoesInput
  }

  export type manutencaoUncheckedCreateWithoutManutencaoInput = {
    id?: number
    veiculo: number
    data_inicio?: Date | string
    valor: number
    descricao: string
    data_fim?: Date | string | null
    concluidas?: boolean
  }

  export type manutencaoCreateOrConnectWithoutManutencaoInput = {
    where: manutencaoWhereUniqueInput
    create: XOR<manutencaoCreateWithoutManutencaoInput, manutencaoUncheckedCreateWithoutManutencaoInput>
  }

  export type manutencaoUpsertWithoutManutencaoInput = {
    update: XOR<manutencaoUpdateWithoutManutencaoInput, manutencaoUncheckedUpdateWithoutManutencaoInput>
    create: XOR<manutencaoCreateWithoutManutencaoInput, manutencaoUncheckedCreateWithoutManutencaoInput>
  }

  export type manutencaoUpdateWithoutManutencaoInput = {
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    data_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
    veiculos?: veiculosUpdateOneRequiredWithoutManutencoesNestedInput
  }

  export type manutencaoUncheckedUpdateWithoutManutencaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    veiculo?: IntFieldUpdateOperationsInput | number
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    data_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
  }

  export type operacoesCreateWithoutRelatoriosInput = {
    data_saida?: Date | string
    descricao: string
    data_retorno?: Date | string | null
    concluidas?: boolean
    tipos: veiculosCreateNestedOneWithoutOperacoesInput
    motoristas: motoristaCreateNestedOneWithoutOperacoesInput
  }

  export type operacoesUncheckedCreateWithoutRelatoriosInput = {
    id?: number
    veiculo: number
    motorista: number
    data_saida?: Date | string
    descricao: string
    data_retorno?: Date | string | null
    concluidas?: boolean
  }

  export type operacoesCreateOrConnectWithoutRelatoriosInput = {
    where: operacoesWhereUniqueInput
    create: XOR<operacoesCreateWithoutRelatoriosInput, operacoesUncheckedCreateWithoutRelatoriosInput>
  }

  export type operacoesUpsertWithoutRelatoriosInput = {
    update: XOR<operacoesUpdateWithoutRelatoriosInput, operacoesUncheckedUpdateWithoutRelatoriosInput>
    create: XOR<operacoesCreateWithoutRelatoriosInput, operacoesUncheckedCreateWithoutRelatoriosInput>
  }

  export type operacoesUpdateWithoutRelatoriosInput = {
    data_saida?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    data_retorno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
    tipos?: veiculosUpdateOneRequiredWithoutOperacoesNestedInput
    motoristas?: motoristaUpdateOneRequiredWithoutOperacoesNestedInput
  }

  export type operacoesUncheckedUpdateWithoutRelatoriosInput = {
    id?: IntFieldUpdateOperationsInput | number
    veiculo?: IntFieldUpdateOperationsInput | number
    motorista?: IntFieldUpdateOperationsInput | number
    data_saida?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    data_retorno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
  }

  export type operacoesCreateManyMotoristasInput = {
    id?: number
    veiculo: number
    data_saida?: Date | string
    descricao: string
    data_retorno?: Date | string | null
    concluidas?: boolean
  }

  export type operacoesUpdateWithoutMotoristasInput = {
    data_saida?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    data_retorno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
    relatorios?: relatorio_operacaoUpdateManyWithoutOperacaoNestedInput
    tipos?: veiculosUpdateOneRequiredWithoutOperacoesNestedInput
  }

  export type operacoesUncheckedUpdateWithoutMotoristasInput = {
    id?: IntFieldUpdateOperationsInput | number
    veiculo?: IntFieldUpdateOperationsInput | number
    data_saida?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    data_retorno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
    relatorios?: relatorio_operacaoUncheckedUpdateManyWithoutOperacaoNestedInput
  }

  export type operacoesUncheckedUpdateManyWithoutOperacoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    veiculo?: IntFieldUpdateOperationsInput | number
    data_saida?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    data_retorno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
  }

  export type veiculosCreateManyTiposInput = {
    id?: number
    placa: string
    uso?: boolean
  }

  export type veiculosUpdateWithoutTiposInput = {
    placa?: StringFieldUpdateOperationsInput | string
    uso?: BoolFieldUpdateOperationsInput | boolean
    manutencoes?: manutencaoUpdateManyWithoutVeiculosNestedInput
    operacoes?: operacoesUpdateManyWithoutTiposNestedInput
  }

  export type veiculosUncheckedUpdateWithoutTiposInput = {
    id?: IntFieldUpdateOperationsInput | number
    placa?: StringFieldUpdateOperationsInput | string
    uso?: BoolFieldUpdateOperationsInput | boolean
    manutencoes?: manutencaoUncheckedUpdateManyWithoutVeiculosNestedInput
    operacoes?: operacoesUncheckedUpdateManyWithoutTiposNestedInput
  }

  export type veiculosUncheckedUpdateManyWithoutVeiculosInput = {
    id?: IntFieldUpdateOperationsInput | number
    placa?: StringFieldUpdateOperationsInput | string
    uso?: BoolFieldUpdateOperationsInput | boolean
  }

  export type manutencaoCreateManyVeiculosInput = {
    id?: number
    data_inicio?: Date | string
    valor: number
    descricao: string
    data_fim?: Date | string | null
    concluidas?: boolean
  }

  export type operacoesCreateManyTiposInput = {
    id?: number
    motorista: number
    data_saida?: Date | string
    descricao: string
    data_retorno?: Date | string | null
    concluidas?: boolean
  }

  export type manutencaoUpdateWithoutVeiculosInput = {
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    data_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
    manutencao?: relatorio_manutencaoUpdateManyWithoutManutencoesNestedInput
  }

  export type manutencaoUncheckedUpdateWithoutVeiculosInput = {
    id?: IntFieldUpdateOperationsInput | number
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    data_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
    manutencao?: relatorio_manutencaoUncheckedUpdateManyWithoutManutencoesNestedInput
  }

  export type manutencaoUncheckedUpdateManyWithoutManutencoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    valor?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    data_fim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
  }

  export type operacoesUpdateWithoutTiposInput = {
    data_saida?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    data_retorno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
    relatorios?: relatorio_operacaoUpdateManyWithoutOperacaoNestedInput
    motoristas?: motoristaUpdateOneRequiredWithoutOperacoesNestedInput
  }

  export type operacoesUncheckedUpdateWithoutTiposInput = {
    id?: IntFieldUpdateOperationsInput | number
    motorista?: IntFieldUpdateOperationsInput | number
    data_saida?: DateTimeFieldUpdateOperationsInput | Date | string
    descricao?: StringFieldUpdateOperationsInput | string
    data_retorno?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concluidas?: BoolFieldUpdateOperationsInput | boolean
    relatorios?: relatorio_operacaoUncheckedUpdateManyWithoutOperacaoNestedInput
  }

  export type relatorio_operacaoCreateManyOperacaoInput = {
    id?: number
  }

  export type relatorio_operacaoUpdateWithoutOperacaoInput = {

  }

  export type relatorio_operacaoUncheckedUpdateWithoutOperacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type relatorio_operacaoUncheckedUpdateManyWithoutRelatoriosInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type relatorio_manutencaoCreateManyManutencoesInput = {
    id?: number
  }

  export type relatorio_manutencaoUpdateWithoutManutencoesInput = {

  }

  export type relatorio_manutencaoUncheckedUpdateWithoutManutencoesInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type relatorio_manutencaoUncheckedUpdateManyWithoutManutencaoInput = {
    id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}